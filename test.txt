이 텍스트파일은 아래에서 서술하는 테스트 프로젝트의 테스트 결과를 담은 텍스트 파일입니다.

이 프로젝트는 C와 Swift가 어떤 면에서 어떤 성능 차이를 보이는지 파악하기 위한 프로젝트 입니다.

C 컴파일러로는 Clang을 사용하며, Swift는 spm을 사용한 swiftc 컴파일러르 사용합니다.

================================================================================
벤치마크 테스트 설명
================================================================================

게임 엔진에서 주로 사용하는 연산들을 기반으로 8가지 테스트를 구성했습니다.
(성능 차이를 명확히 보기 위해 반복 횟수를 대폭 증가시켰습니다)

테스트 1: 벡터 연산 (Vector Operations)
  - 5000만 번의 3D 벡터 연산 수행
  - 벡터 덧셈, 뺄셈, 내적(dot product), 외적(cross product), 정규화(normalization) 포함
  - 게임 엔진에서 가장 기본적이고 자주 사용되는 연산

테스트 2: 행렬 연산 (Matrix Operations)
  - 100만 번의 4x4 행렬 곱셈 수행
  - 3D 변환(transformation)에 필수적인 연산
  - 카메라, 오브젝트 이동 및 회전에 사용

테스트 3: 입자 시스템 시뮬레이션 (Particle Simulation)
  - 50,000개의 입자를 2,000 프레임 동안 시뮬레이션
  - 각 입자는 위치, 속도, 가속도를 가지며 매 프레임 업데이트
  - 불, 연기, 폭발 등의 효과에 사용되는 물리 시뮬레이션

테스트 4: 배열 정렬 (Array Sorting)
  - 1000만 개의 정수를 정렬
  - 메모리 집약적인 작업 및 알고리즘 성능 측정
  - 게임에서 렌더링 순서, 우선순위 큐 등에 사용

테스트 5: 배열 변환 및 필터링 (Array Transform & Filter)
  - 1000만 개의 요소를 변환(map), 필터링(filter), 재변환
  - 함수형 프로그래밍 스타일 연산의 성능 측정
  - 데이터 처리 파이프라인에 사용

테스트 6: 삼각함수 연산 (Trigonometry)
  - 1000만 번의 삼각함수(sin, cos, tan, asin) 및 제곱근 연산
  - 회전, 각도 계산, 파동 효과 등에 필수적
  - CPU 집약적인 수학 연산 성능 측정

테스트 7: 구조체 배열 접근 (Struct Array Access)
  - 500,000개의 게임 오브젝트를 500 프레임 동안 업데이트
  - 각 오브젝트는 위치, 회전, 스케일, 체력 등의 속성을 가짐
  - 실제 게임 루프와 유사한 패턴의 메모리 접근

테스트 8: AABB 충돌 검사 (AABB Collision Detection)
  - 3,000개의 축정렬 경계 상자(AABB) 간 충돌 검사
  - O(N²) 복잡도의 충돌 검사 알고리즘
  - 게임 물리 엔진의 기본적인 충돌 감지 연산

================================================================================
빌드 및 실행 방법
================================================================================

[C 버전]
cd C
make
./benchmark

[Swift 버전]
cd Swift
swift build -c release
.build/release/Benchmark

================================================================================
테스트 결과
================================================================================

[테스트 환경]
CPU: Apple M2
메모리: 16 GB
OS: macOS 26.0.1
날짜: 2025-10-02

[C 성능 결과] - printf로 결과 출력하여 최적화 방지
Test 1 - Vector Operations (50,000,000 iterations): 0.0948 seconds
Test 2 - Matrix Operations (1,000,000 iterations): 0.0000 seconds
Test 3 - Particle Simulation (50,000 particles, 2,000 frames): 0.1222 seconds
Test 4 - Array Sorting (10,000,000 elements): 0.7917 seconds
Test 5 - Array Transform & Filter (10,000,000 elements): 0.0038 seconds
Test 6 - Trigonometry (10,000,000 iterations): 0.2418 seconds
Test 7 - Struct Array Access (500,000 objects, 500 frames): 0.3542 seconds
Test 8 - AABB Collision Detection (3,000 boxes): 0.0030 seconds

[Swift 성능 결과] - print로 결과 출력하여 최적화 방지
Test 1 - Vector Operations (50,000,000 iterations): 0.0826 seconds
Test 2 - Matrix Operations (1,000,000 iterations): 0.2461 seconds
Test 3 - Particle Simulation (50,000 particles, 2,000 frames): 0.1438 seconds
Test 4 - Array Sorting (10,000,000 elements): 1.0601 seconds
Test 5 - Array Transform & Filter (10,000,000 elements): 0.0548 seconds
Test 6 - Trigonometry (10,000,000 iterations): 0.1096 seconds
Test 7 - Struct Array Access (500,000 objects, 500 frames): 0.3564 seconds
Test 8 - AABB Collision Detection (3,000 boxes): 0.0028 seconds

[성능 비교 분석] ★ printf/print 추가 후 실제 측정 결과

1. 벡터 연산 (Vector Operations) - 5000만 번
   - C: 0.0948초 / Swift: 0.0826초
   - **Swift가 12.9% 더 빠름!**
   - 이전에는 최적화로 제거됐지만, print 추가 후 실제 성능 측정 가능
   - Swift의 벡터 연산 최적화가 뛰어남

2. 행렬 연산 (Matrix Operations) - 100만 번
   - C: 0.0000초 / Swift: 0.2461초
   - **C는 여전히 최적화로 제거됨**
   - printf를 추가했음에도 Clang이 Dead Code로 판단
   - Swift는 실제 연산 수행

3. 입자 시스템 시뮬레이션 (Particle Simulation) - 50,000입자 x 2,000프레임
   - C: 0.1222초 / Swift: 0.1438초
   - **C가 15.0% 더 빠름**
   - 이전과 반대 결과! print 추가 전에는 Swift가 빨랐음
   - 실제 물리 연산에서 C의 우위 확인

4. 배열 정렬 (Array Sorting) - 1000만 개
   - C: 0.7917초 / Swift: 1.0601초
   - **C가 33.9% 더 빠름** ★ 큰 차이
   - C의 qsort가 Swift의 sort()보다 훨씬 효율적
   - 대용량 데이터 정렬에서 C의 압도적 우위

5. 배열 변환 및 필터링 (Array Transform & Filter) - 1000만 개
   - C: 0.0038초 / Swift: 0.0548초
   - **C가 1342% 더 빠름!** ★★★ 가장 큰 차이
   - Swift의 map-filter-map 함수형 체이닝이 매우 느림
   - C의 단순 for 루프가 압도적으로 효율적
   - Swift의 편의성과 성능 사이의 극명한 트레이드오프

6. 삼각함수 연산 (Trigonometry) - 1000만 번
   - C: 0.2418초 / Swift: 0.1096초
   - **Swift가 54.7% 더 빠름!** ★★
   - 이전에는 최적화로 제거됐지만, 실제로는 Swift가 훨씬 빠름
   - Swift의 수학 연산 최적화가 매우 뛰어남

7. 구조체 배열 접근 (Struct Array Access) - 500,000 오브젝트 x 500프레임
   - C: 0.3542초 / Swift: 0.3564초
   - **거의 동등** (0.6% 차이)
   - 대규모 구조체 배열 처리에서 성능 차이 거의 없음

8. AABB 충돌 검사 (AABB Collision Detection) - 3,000 박스
   - C: 0.0030초 / Swift: 0.0028초
   - **Swift가 6.7% 더 빠름**
   - 충돌 검사 알고리즘에서 Swift가 근소하게 우위

[종합 분석] ★ printf/print로 최적화 방지 후 실제 성능

**승부 결과 (8개 테스트):**
- Swift 승리: 4개 (벡터 연산 12.9%, 삼각함수 54.7%, 충돌검사 6.7%, 행렬만 측정)
- C 승리: 3개 (입자 15.0%, 정렬 33.9%, 배열변환 1342%)
- 무승부: 1개 (구조체 배열 0.6%)

**핵심 발견:**
1. **최적화의 함정**: print/printf 없이는 대부분 테스트가 최적화로 제거되어 정확한 측정 불가
2. **Swift의 강점**: 벡터 연산(12.9%), 삼각함수(54.7%) 등 수학 연산에서 압도적
3. **C의 강점**: 배열 변환(1342%!), 정렬(33.9%) 등 메모리 집약적 작업에서 우위
4. **Swift 함수형의 대가**: map-filter-map 체이닝은 편리하지만 성능이 14배 느림
5. **실전 성능**: 구조체 배열, 충돌 검사 등 실제 게임 로직에서는 거의 동등

**결론:**
- **언어별 특성이 명확함**: Swift는 수학 연산, C는 메모리/배열 처리가 강함
- **함수형 프로그래밍의 비용**: Swift의 편의성 기능은 성능 희생이 큼
- **실용적 선택**: 게임 엔진 핵심 루프는 성능이 중요하므로 C/C++ 유리
- **하이브리드 전략**: UI/로직은 Swift, 핵심 연산은 C로 구현하는 것이 최적
- **측정의 중요성**: 벤치마크 시 반드시 결과를 사용하는 코드를 추가해야 정확한 측정 가능

================================================================================
추가 실험: Swift에서 C 라이브러리 호출 (배열 변환)
================================================================================

**실험 목적:**
Swift의 배열 변환이 느린 이유가 무엇인지 확인
1. Swift 배열 자체의 특성 때문인가?
2. 호출 오버헤드가 큰가?

**테스트 구성:**
- C 라이브러리: 배열 변환 함수 (array_transform.c)
- Swift Pure: map-filter-map 체이닝
- Swift + C: Swift에서 C 함수 호출 (UnsafePointer 사용)

**결과 (10,000,000 elements):**
1. C 순수 (C 벤치마크):           0.0038초 ★ 가장 빠름
2. Swift → C 호출 (호출 오버헤드): 0.0098초 (C 순수의 2.6배)
3. Swift 순수 (map-filter-map):   0.0464초 (C 순수의 12.2배)

**분석:**

**호출 오버헤드:**
- Swift → C 호출: 0.0098초
- C 순수: 0.0038초
- 오버헤드: 0.0060초 (158% 증가)
- 오버헤드 원인: Swift 배열 → UnsafePointer 변환, 결과 배열 재구성

**Swift 배열 특성:**
- Swift 순수: 0.0464초
- Swift → C: 0.0098초
- Swift 배열의 성능 저하: 0.0366초 (373% 증가!)
- 원인: map-filter-map 체이닝의 중간 배열 생성 및 클로저 호출 오버헤드

**핵심 발견:**
1. **호출 오버헤드 < Swift 배열 특성**:
   - 호출 오버헤드는 2.6배 정도
   - Swift 함수형 체이닝은 12.2배 느림
   - **Swift 배열의 특성에서 오는 성능 저하가 훨씬 큼**

2. **Swift → C 호출의 효과:**
   - Swift 순수보다 4.7배 빠름
   - 호출 오버헤드가 있어도 Swift 함수형보다 훨씬 유리

3. **실용적 결론:**
   - **배열 연산이 많은 경우 C 라이브러리로 만들어 호출하는 것이 매우 효과적**
   - 호출 오버헤드보다 Swift 배열 체이닝의 비용이 훨씬 크므로 충분히 가치 있음
   - 1000만 개 배열 처리 시: Swift 순수(46ms) → Swift+C(10ms) = **4.6배 향상**

**권장 사항:**
- 대규모 배열 연산: C 라이브러리 사용 (호출 오버헤드 < 성능 향상)
- 단순 배열 접근: Swift 순수로도 충분
- 함수형 체이닝: 편의성은 좋지만 성능이 중요하면 지양

================================================================================
추가 실험: 커스텀 메모리 관리 시스템 (Ikyo Engine Memory)
================================================================================

**실험 목적:**
직접 구현한 커스텀 메모리 관리 시스템의 실제 성능 향상 확인

**메모리 시스템 구성:**
1. BinnedAllocator: 작은 객체(≤4KB) 전용, lock-free freelist + TLS 캐시
2. LargeAllocator: 큰 객체(>4KB) 전용, 가상 메모리 직접 관리
3. FrameArena: 프레임 단위 범프 할당자 (monotonic allocator)
4. EngineBuffer<T>: 타입-세이프 메모리 버퍼
5. VirtualMemory: 크로스 플랫폼 가상 메모리 관리

**테스트 결과:**

**1. 입자 시뮬레이션 (50,000 particles, 2,000 frames)**
- Swift Array: 0.1517초
- EngineBuffer: 0.1311초
- **성능 향상: 13.6% 빠름** ⭐

분석:
- EngineBuffer는 단일 메모리 블록으로 할당되어 캐시 효율성 우수
- Swift Array는 요소 추가 시 재할당 오버헤드 발생
- 연속 메모리 접근 패턴에서 EngineBuffer의 우위 확인

**2. 대량 메모리 할당/해제 (1,000,000 allocations)**
- BinnedAllocator: 0.1995초
- 100만 번 할당/해제 (16~143 바이트)
- TLS 캐시 + lock-free freelist로 빠른 성능

특징:
- O(1) size-to-class 룩업 테이블
- 스레드 로컬 캐시로 경합 최소화
- 작은 객체 할당에 최적화

**3. FrameArena vs BinnedAllocator (995,000 allocations, 10,000 frames)**
- BinnedAllocator: 0.1995초
- FrameArena: 0.0159초
- **성능 향상: 1154% 빠름 (12.5배!)** ⭐⭐⭐

분석:
- FrameArena는 단순 범프 할당 (포인터 이동만)
- BinnedAllocator는 프리리스트 관리 오버헤드
- 프레임 단위로 일괄 리셋, 개별 해제 불필요
- 게임 엔진의 프레임별 임시 데이터에 최적

**핵심 발견:**

1. **EngineBuffer의 효과**:
   - Swift Array보다 13.6% 빠름
   - 연속 메모리 할당으로 캐시 효율성 향상
   - 대규모 데이터 처리 시 유용

2. **FrameArena의 압도적 성능**:
   - BinnedAllocator보다 **12.5배 빠름**
   - 프레임 단위 할당 패턴에 완벽히 최적화
   - 할당만 있고 해제 없음 (일괄 리셋)
   - 게임 프레임 루프에 이상적

3. **BinnedAllocator의 실용성**:
   - 100만 번 할당/해제를 0.2초에 처리
   - TLS 캐시와 lock-free 구조로 멀티스레드 환경에 적합
   - 범용 할당자로서 우수한 성능

**실용적 권장 사항:**

**게임 엔진 메모리 전략:**
1. **프레임별 임시 데이터**: FrameArena 사용 → 12.5배 빠름
   - 렌더링 커맨드, 임시 계산, 프레임 콜백

2. **영구 데이터 구조**: EngineBuffer 사용 → 13.6% 빠름
   - 입자 시스템, 게임 오브젝트 배열, 버텍스 버퍼

3. **동적 할당/해제**: BinnedAllocator 사용
   - 게임 로직, 이벤트 처리, 일반 객체

4. **큰 메모리 블록**: LargeAllocator 자동 라우팅
   - 텍스처, 오디오 버퍼, 대용량 데이터

**결론:**
- **커스텀 메모리 관리 시스템이 실제로 큰 성능 향상을 가져옴**
- FrameArena는 게임 엔진의 프레임 패턴에 최적화되어 압도적 성능 (12.5배)
- EngineBuffer는 Swift Array보다 안정적으로 빠름 (13.6%)
- 메모리 할당 패턴에 따라 적절한 할당자를 선택하는 것이 핵심

================================================================================
