EnTT ECS Architecture Analysis
==============================

Based on comprehensive analysis of the EnTT C++ implementation (used in Minecraft)

---

## 1. CORE ARCHITECTURE: Pure Sparse-Set Based

EnTT uses a **pure sparse-set architecture**, fundamentally different from archetype-based systems.

**Key Principle**:
One sparse set per component type. Entities can have any combination of components without structural reorganization.

**Architecture Comparison**:
- **Archetype-based (Bevy)**: Groups entities by component signature, moves entities between tables when components change
- **Sparse-set (EnTT)**: Each component type has its own sparse set, O(1) add/remove, no memory moves

**Trade-off**:
- Faster component addition/removal (no archetype transitions)
- Slower iteration (multi-pool traversal) unless using groups


---

## 2. ENTITY REPRESENTATION

### Entity Structure (entity.hpp)

```cpp
// Entity is a 32-bit or 64-bit packed integer

// 32-bit variant
template<>
struct entt_traits<std::uint32_t> {
    using entity_type = std::uint32_t;
    using version_type = std::uint16_t;

    static constexpr entity_type entity_mask = 0xFFFFF;    // 20 bits for entity ID (1M entities)
    static constexpr entity_type version_mask = 0xFFF;     // 12 bits for version (4096 generations)
    static constexpr std::size_t entity_shift = 20;
};

// 64-bit variant
template<>
struct entt_traits<std::uint64_t> {
    using entity_type = std::uint64_t;
    using version_type = std::uint32_t;

    static constexpr entity_type entity_mask = 0xFFFFFFFF;    // 32 bits for entity ID (4B entities)
    static constexpr entity_type version_mask = 0xFFFFFFFF;   // 32 bits for version
    static constexpr std::size_t entity_shift = 32;
};
```

**Entity Properties**:
- **Generational index**: Version increments on entity destruction/reuse
- **Null entity**: Special sentinel value `entity_mask | (version_mask << entity_shift)`
- **Tombstone**: Used for in-place deletion tracking (pointer stability mode)
- **Bit packing**: Extract ID via `entity & entity_mask`, version via `entity >> entity_shift`

**Entity Operations**:
```cpp
// Create entity (recycle from free list or allocate new)
entity_type create();

// Destroy entity (increment version, add to free list)
version_type destroy(entity_type entt);

// Check if entity is alive
bool valid(entity_type entt) const;

// Get current version of entity
version_type current(entity_type entt) const;
```


---

## 3. SPARSE SET IMPLEMENTATION

### Core Data Structure (sparse_set.hpp)

The sparse set is the **fundamental building block** of EnTT. Everything builds on top of it.

```cpp
template<typename Entity, typename Allocator>
class basic_sparse_set {
private:
    sparse_container_type sparse;  // Array of page pointers (sparse index)
    packed_container_type packed;  // Dense array of entities
    deletion_policy mode;          // swap_and_pop | in_place | swap_only
    size_type head;                // Free list head or swap boundary
};
```

### Two-Array Design

**Sparse Array** (paged):
```cpp
std::vector<pointer_type> sparse;  // Array of page pointers
```

- **Purpose**: Fast entity → dense index lookup
- **Paged structure**:
  - Each page holds `page_size` indices (default: 4096)
  - Page index: `entity_id / page_size`
  - Offset: `entity_id % page_size`
- **Lazy allocation**: Pages allocated on-demand
- **Stores**: Index into packed array (or special values: null, tombstone)

**Packed Array** (dense):
```cpp
std::vector<Entity> packed;  // Contiguous dense storage
```

- **Purpose**: Cache-friendly iteration
- **Contains**: Only live entities (no holes in default mode)
- **Iteration**: Linear scan, excellent cache locality

### Sparse Array Paging

```cpp
[[nodiscard]] auto sparse_ptr(const Entity entt) const {
    const auto pos = entity_to_pos(entt);  // Extract entity ID
    const auto page = pos_to_page(pos);    // pos / page_size

    return (page < sparse.size() && sparse[page])
        ? (sparse[page] + fast_mod(pos, traits_type::page_size))  // Return pointer to index
        : nullptr;
}
```

**Benefits of Paging**:
- Avoids huge contiguous allocations for sparse IDs
- Grows incrementally as entity IDs increase
- Each page: 4096 * sizeof(entity_type) = 16KB per page
- Good cache behavior within a page

**Memory Layout Example**:
```
Sparse array for entities 0-8191:

sparse: [page0*, page1*, nullptr, nullptr, ...]
         │       │
         ▼       ▼
page0: [0, 1, 2, ..., 4095]  (indices into packed array)
page1: [4096, 4097, ..., 8191]

packed: [E0, E1, E2, E3, ...]  (actual entities in dense order)
```

### Deletion Policies

EnTT supports **three deletion policies** to handle different requirements:

#### 1. swap_and_pop (Default)

```cpp
void swap_and_pop(const basic_iterator it) {
    auto &self = sparse_ref(*it);
    const auto entt = traits_type::to_entity(self);

    // Update sparse index for swapped entity
    sparse_ref(packed.back()) = traits_type::combine(entt, ...);

    // Swap with last element
    packed[entt] = packed.back();

    // Mark as removed
    self = null;

    // Remove last element
    packed.pop_back();
}
```

**Characteristics**:
- **O(1) deletion**: Swap with last, then pop
- **No holes**: Packed array stays contiguous
- **Breaks iteration order**: Entities move during deletion
- **No pointer stability**: Indices change
- **Use case**: Default mode, maximum performance

#### 2. in_place (Pointer Stability)

```cpp
void in_place_pop(const basic_iterator it) {
    const auto pos = entity_to_pos(std::exchange(sparse_ref(*it), null));

    // Replace with tombstone
    packed[pos] = traits_type::combine(head, tombstone);

    // Add to free list
    head = pos;
}
```

**Characteristics**:
- **O(1) deletion**: Leave tombstone in place
- **Pointer stability**: Indices never change
- **Creates holes**: Packed array becomes fragmented
- **Free list**: Linked list of holes for reuse
- **Use case**: When components contain pointers/references to other components

#### 3. swap_only (Group Support)

```cpp
void swap_only(const basic_iterator it) {
    const auto pos = index(*it);
    bump(traits_type::next(*it));

    // Swap but keep in array
    swap_at(pos, head -= (pos < head));
}
```

**Characteristics**:
- **Swap without removal**: Moves entity past group boundary
- **Maintains partitioning**: Group members stay at front
- **Used internally**: For group cache maintenance
- **Not user-facing**: Automatic in group mode

### Sparse Set Operations

**Add Entity**:
```cpp
basic_iterator push(const Entity entt) {
    // Ensure sparse page exists
    assure_at_least(entity_to_pos(entt));

    // Add to dense array
    packed.push_back(entt);

    // Update sparse index
    sparse_ref(entt) = packed.size() - 1;

    return begin() + (packed.size() - 1);
}
```

**Contains Check** (O(1)):
```cpp
[[nodiscard]] bool contains(const Entity entt) const {
    const auto *ptr = sparse_ptr(entt);
    return ptr && *ptr != null && traits_type::to_entity(packed[*ptr]) == entt;
}
```

**Index Lookup** (O(1)):
```cpp
[[nodiscard]] size_type index(const Entity entt) const {
    return static_cast<size_type>(sparse_ref(entt));
}
```

**Iteration** (O(N)):
```cpp
for(const auto entity : sparse_set) {
    // Linear scan of packed array
}
```


---

## 4. COMPONENT STORAGE

### Storage Structure (storage.hpp)

```cpp
template<typename Type, typename Entity, typename Allocator>
class basic_storage : public basic_sparse_set<Entity, ...> {
private:
    container_type payload;  // vector<pointer> - paged component array
};
```

**Design**:
- **Inherits from sparse_set**: Reuses entity tracking (packed/sparse arrays)
- **Adds component storage**: Separate paged array for actual component data
- **Parallel arrays**: Component index matches entity index in sparse_set

### Memory Layout

```cpp
// Storage for Position components

Inherited from sparse_set:
  sparse: [page0*, page1*, ...]  (entity_id -> dense index)
  packed: [E0, E1, E2, E3, ...]  (dense entity array)

Component storage:
  payload: [page0*, page1*, ...]
            │
            ▼
  page0: [Position0, Position1, Position2, ..., Position4095]

// Position for entity E0 is at payload[0][0]
// Position for entity E1 is at payload[0][1]
```

**Alignment**:
- Each component page is aligned to component alignment requirements
- Default page size: 4096 components per page
- Page size can be customized per component type

### Component Access

**Element Access**:
```cpp
[[nodiscard]] auto &element_at(const std::size_t pos) const {
    return payload[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
}
```

**Get by Entity** (O(1)):
```cpp
template<typename... Args>
[[nodiscard]] decltype(auto) get(const Entity entt) const {
    return element_at(index(entt));  // index() is O(1) sparse lookup
}
```

**Emplace Component**:
```cpp
template<typename... Args>
basic_iterator emplace(const Entity entt, Args &&...args) {
    if(auto it = find(entt); it == end()) {
        // Allocate in component storage
        assure_at_least(packed.size());

        // Construct component in-place
        auto *elem = &payload[packed.size() / page_size][packed.size() % page_size];
        std::construct_at(elem, std::forward<Args>(args)...);

        // Add entity to sparse set
        push(entt);

        return it;
    }
    return it;
}
```

### Empty Component Optimization

```cpp
template<typename Type, typename Entity, typename Allocator>
class basic_storage<Type, Entity, Allocator,
    std::enable_if_t<component_traits<Type, Entity>::page_size == 0u>>
    : public basic_sparse_set<Entity, ...> {
    // No payload storage!
    // Only tracks entity membership via sparse_set
};
```

**Tag Components** (zero-size types):
- No component data stored
- Only sparse_set for membership tracking
- `page_size == 0` specialization
- Perfect for marker/flag components

**Example**:
```cpp
struct Player {};  // Tag component

registry.emplace<Player>(entity);  // Only adds to sparse_set, no data allocated
```


---

## 5. REGISTRY (WORLD)

### Registry Structure (registry.hpp)

```cpp
template<typename Entity, typename Allocator>
class basic_registry {
private:
    using pool_container_type = dense_map<id_type, std::shared_ptr<base_type>>;
    using group_container_type = dense_map<id_type, group_handler>;

    context vars;                          // Type-erased context storage
    pool_container_type pools;             // Map: type_hash<T> -> storage<T>
    group_container_type groups;           // Map: group_id -> group_handler
    storage_for_type<entity_type> entities; // Special entity storage
};
```

**Key Components**:
- **pools**: Hash map of all component storages (type-erased)
- **groups**: Hash map of group handlers (cached queries)
- **entities**: Special storage tracking entity lifecycle
- **vars**: Generic context for user data (like resources)

### Type Erasure

**Common Base Type**:
```cpp
using base_type = basic_sparse_set<Entity, Allocator>;
```

All component storages derive from `basic_sparse_set`, enabling:
```cpp
dense_map<id_type, std::shared_ptr<base_type>> pools;
```

**Type ID System**:
```cpp
template<typename Type>
[[nodiscard]] static id_type type() noexcept {
    return type_hash<Type>::value();  // Compile-time unique ID
}
```

### Pool Management

**Lazy Initialization**:
```cpp
template<typename Type>
[[nodiscard]] auto &assure(const id_type id = type_hash<Type>::value()) {
    // Try to find existing pool
    if(auto it = pools.find(id); it != pools.cend()) {
        return static_cast<storage_type<Type> &>(*it->second);
    }

    // Create new pool
    auto cpool = std::allocate_shared<storage_type<Type>>(get_allocator(), ...);
    pools.emplace(id, cpool);

    // Connect signals for groups
    cpool->bind(*this);

    return *cpool;
}
```

**Benefits**:
- Storage only created when first component of that type is added
- Type-safe access via template parameter
- O(1) lookup after creation

### Entity Operations

**Create Entity**:
```cpp
[[nodiscard]] entity_type create() {
    return entities.emplace();  // Delegates to entity sparse_set
}

[[nodiscard]] entity_type create(const entity_type hint) {
    return entities.emplace(hint);  // Try to reuse specific ID
}
```

**Destroy Entity**:
```cpp
void destroy(const entity_type entt) {
    // Remove from all component pools
    for(size_type pos = pools.size(); pos; --pos) {
        if(auto &pdata = pools.begin()[pos - 1u]; pdata.second->contains(entt)) {
            pdata.second->remove(entt);
        }
    }

    // Release entity ID (increment version)
    entities.erase(entt);
}
```

**Complexity**: O(C) where C = number of component types in registry (not per entity!)

### Component Operations

**Add Component**:
```cpp
template<typename Type, typename... Args>
decltype(auto) emplace(const entity_type entt, Args &&...args) {
    return assure<Type>().emplace(entt, std::forward<Args>(args)...);
}
```

**Remove Component**:
```cpp
template<typename Type>
size_type remove(const entity_type entt) {
    return assure<Type>().remove(entt);
}
```

**Get Component**:
```cpp
template<typename Type>
[[nodiscard]] decltype(auto) get(const entity_type entt) const {
    return assure<Type>().get(entt);
}
```

**All O(1)** operations (no archetype moves).


---

## 6. VIEW SYSTEM

Views provide **non-owning, temporary query access** over multiple component pools.

### View Structure (view.hpp)

```cpp
template<typename... Get, typename... Exclude>
class basic_view<get_t<Get...>, exclude_t<Exclude...>>
    : public basic_common_view {
private:
    std::array<const common_type *, sizeof...(Get)> pools;    // Component pools to include
    std::array<const common_type *, sizeof...(Exclude)> filter; // Component pools to exclude
    size_type index;  // Index of smallest pool (lead pool)
};
```

**View Types**:
1. **Single-component view**: Direct iteration, no filtering
2. **Multi-component view**: Lead pool iteration + filtering
3. **Excluding view**: Additional exclusion checks

### Lead Pool Selection

```cpp
void unchecked_refresh() noexcept {
    index = 0u;

    if constexpr(sizeof...(Get) > 1u) {
        // Find smallest pool
        for(size_type pos{1u}; pos < sizeof...(Get); ++pos) {
            if(pools[pos]->size() < pools[index]->size()) {
                index = pos;
            }
        }
    }
}
```

**Strategy**:
- Iterate the **smallest pool** for efficiency
- Check membership in other pools for each entity
- Excludes checked via sparse array lookup

**Example**:
```
Query: <Position, Velocity, Health>
Pool sizes: Position=10000, Velocity=5000, Health=100

Lead pool: Health (smallest)
Iterate: 100 entities
For each: Check Position.contains() + Velocity.contains()
Result: Much faster than iterating 10000 entities
```

### Multi-Pool Iteration

```cpp
template<typename Type, bool Checked, std::size_t Get, std::size_t Exclude>
class view_iterator {
    [[nodiscard]] bool valid(const entity_type entt) const noexcept {
        // Check not tombstone (if in_place deletion)
        const auto is_valid = !Checked || (entt != tombstone);

        // Check membership in all Get pools (skip lead pool)
        const auto has_all = (Get == 1u) ||
            internal::all_of(pools.begin(), pools.begin() + Get,
                [entt](auto *pool) { return pool->contains(entt); });

        // Check exclusion in all Exclude pools
        const auto has_none = (Exclude == 0u) ||
            internal::none_of(filter.begin(), filter.begin() + Exclude,
                [entt](auto *pool) { return pool->contains(entt); });

        return is_valid && has_all && has_none;
    }

    void next() {
        while(++it != sentinel && !valid(*it)) {}
    }
};
```

**Performance**:
- **Best case**: O(N) where N = size of smallest pool
- **Worst case**: O(N × M) where M = number of pools (contains() checks)
- **Exclude overhead**: Minimal (O(1) sparse lookup)

### Single-Pool Optimization

```cpp
template<typename Get>
class basic_view<get_t<Get>, exclude_t<>>
    : public basic_storage_view<...> {
    // Direct iteration over single storage
    // No filtering needed
    // Perfect performance: O(N) linear with no checks
};
```

**Fast path** for queries like `view<Position>()`.

### View Usage Patterns

**Range-based iteration**:
```cpp
auto view = registry.view<Position, Velocity>();

for(auto entity : view) {
    auto &pos = view.get<Position>(entity);
    auto &vel = view.get<Velocity>(entity);
    // ...
}
```

**Structured binding**:
```cpp
for(auto [entity, pos, vel] : view.each()) {
    pos.x += vel.dx;
    pos.y += vel.dy;
}
```

**Callback iteration**:
```cpp
view.each([](auto entity, Position &pos, Velocity &vel) {
    pos.x += vel.dx;
});
```


---

## 7. GROUP SYSTEM

Groups provide **cached, pre-filtered** entity sets with **perfect SoA** for owned components.

### Why Groups?

**Problem with Views**:
- Multi-pool iteration: O(N × M)
- Every frame repeats membership checks
- No guarantee of SoA layout

**Solution: Groups**:
- Pre-compute filtered entity set
- Maintain partitioned pools for owned components
- Perfect SoA for owned components (direct indexing)

### Group Types

**1. Owning Groups** (owned_t):
```cpp
auto group = registry.group<Position, Velocity>(entt::get<Health>);
//                          ^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^
//                          Owned (perfect SoA)  Get (still lookup)
```

**2. Non-Owning Groups**:
```cpp
auto group = registry.group<>(entt::get<Position, Velocity>);
//                             All components use lookup
```

### Owning Group Architecture

```cpp
template<typename... Owned, typename... Get, typename... Exclude>
class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
    using handler_type = internal::group_handler<common_type,
                                                  sizeof...(Owned),
                                                  sizeof...(Get),
                                                  sizeof...(Exclude)>;
    handler_type *handler;  // Cache maintenance logic
};
```

### Group Handler (Cache Maintenance)

```cpp
template<typename Type, std::size_t Owned, std::size_t Get, std::size_t Exclude>
class group_handler {
private:
    std::array<common_type *, Owned + Get> pools;
    std::array<common_type *, Exclude> filter;
    std::size_t len{};  // Number of entities in group
};
```

**Key State**:
- `len`: Boundary between group members and non-members
- `pools`: Pointers to owned + get component storages
- `filter`: Pointers to exclude component storages

### Owned Pool Partitioning

```
Owned pool (e.g., Position storage):

packed array:
[0 ... len-1][len ... size-1]
 ^^^^^^^^^^^  ^^^^^^^^^^^^^^^
 Group        Non-group
 members      entities

Group invariant:
- First `len` entities satisfy group criteria
- Remaining entities don't
- All owned pools maintain same entity order
```

**Benefits**:
- Group entities are contiguous
- Perfect SoA layout for owned components
- Direct index access (no sparse lookup needed)

### Signal-Based Updates

Groups connect to component storage signals:

```cpp
void bind(basic_registry &reg) {
    for(auto *cpool : pools) {
        cpool->on_construct().connect<&group_handler::push_if>(*this);
        cpool->on_destroy().connect<&group_handler::remove_if>(*this);
    }
}
```

**On Component Add**:
```cpp
template<std::size_t Index>
void push_if(const entity_type entt) {
    if(!filter[0u]->contains(entt) && all_owned_match(entt) && all_get_match(entt)) {
        // Entity now matches group criteria
        // Move to group region in all owned pools
        for(auto *cpool : owned_pools()) {
            const auto pos = cpool->index(entt);
            cpool->swap_elements(len, pos);  // Swap with boundary
        }
        ++len;  // Expand group region
    }
}
```

**On Component Remove**:
```cpp
void remove_if(const entity_type entt) {
    if(pools[0u]->contains(entt)) {
        const auto pos = pools[0u]->index(entt);
        if(pos < len) {
            // Entity was in group, remove it
            for(auto *cpool : owned_pools()) {
                cpool->swap_elements(--len, pos);  // Swap with boundary
            }
        }
    }
}
```

**Automatic Maintenance**:
- Every component add/remove triggers signal
- Group handler updates partitioning
- O(Owned) cost per structural change
- Amortized by avoiding repeated filtering

### Perfect SoA Iteration

```cpp
template<typename... Owned>
[[nodiscard]] iterable each() const noexcept {
    return iterable{{begin(), cpools}, {end(), cpools}};
}

// Group iterator dereference
reference operator*() const noexcept {
    const auto pos = index_to_element(*it);  // Entity index in packed array

    return std::tuple_cat(
        std::make_tuple(*it),                           // Entity
        std::make_tuple(cpools[Owned][pos])...,        // Owned: direct index!
        std::get<Get *>(pools)->get_as_tuple(*it)...   // Get: still lookup
    );
}
```

**Key Difference**:
- **Owned components**: `pool[entity_index]` - direct array access, no sparse lookup
- **Get components**: `pool.get(entity)` - still requires sparse lookup
- **Result**: Perfect cache locality for owned components

**Performance**:
```
Iterate 10,000 entities with <Position (owned), Velocity (owned), Health (get)>

Without group:
  - 10,000 × 3 sparse lookups = 30,000 random memory accesses

With group:
  - 10,000 × 2 direct accesses (Position, Velocity) = sequential
  - 10,000 × 1 sparse lookup (Health) = 10,000 random accesses

Result: ~3x fewer cache misses
```

### Non-Owning Groups

```cpp
template<typename... Get, typename... Exclude>
class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
    common_type elem;  // Cached sparse_set of matching entities
};
```

**Characteristics**:
- No ownership over pools
- Maintains separate sparse_set with filtered entities
- Updated via signals (like owning groups)
- Faster than views (pre-filtered)
- Slower than owning groups (no direct access)

### Group Usage

```cpp
auto group = registry.group<Position, Velocity>(entt::get<Health>);

// Iterate with perfect SoA for Position, Velocity
for(auto [entity, pos, vel, health] : group.each()) {
    pos.x += vel.dx;  // Sequential access!
    pos.y += vel.dy;  // Sequential access!

    if(health.value < 0) {
        registry.destroy(entity);
    }
}
```


---

## 8. VIEWS VS GROUPS: PERFORMANCE TRADE-OFFS

| Aspect | Views | Owning Groups | Non-Owning Groups |
|--------|-------|---------------|-------------------|
| **Setup Cost** | O(1) - just references | O(N) - scan all entities + signals | O(N) - scan + signals |
| **Update Cost** | None | O(Owned) per component change | O(1) per match change |
| **Iteration** | O(N × M) - multi-pool | O(N) - perfect SoA | O(N × M) - lookup needed |
| **Memory** | No overhead | Pool partitioning overhead | Separate entity cache |
| **Cache Locality** | Poor (multiple lookups) | Excellent (owned SoA) | Poor (lookups) |
| **Flexibility** | Full flexibility | Can sort owned types | Can sort cache |
| **Best For** | One-off queries | Hot paths (every frame) | Moderate frequency |

### When to Use Each

**Views**:
- Queries executed rarely
- Dynamic queries (unknown at startup)
- Prototyping and debugging
- Queries with many component types

**Owning Groups**:
- Systems running every frame
- Tight inner loops with 2-3 components
- When SoA layout critical for performance
- Stable query patterns

**Non-Owning Groups**:
- Moderate frequency (not every frame)
- When ownership conflicts prevent owning groups
- Complex filter logic with many excludes

### Example Decision

```cpp
// Physics system runs every frame with tight loop
// Use owning group for perfect SoA
auto physics = registry.group<Position, Velocity>(entt::get<Mass>);

// Damage system runs occasionally on events
// Use view (simpler, no setup cost)
auto damaged = registry.view<Health, DamageEvent>();

// Rendering system runs every frame but has many component types
// Use non-owning group (can't own all)
auto renderable = registry.group<>(entt::get<Transform, Mesh, Material>);
```


---

## 9. MEMORY MANAGEMENT

### Paged Allocation Strategy

**Default Configuration**:
```cpp
static constexpr std::size_t page_size = ENTT_PACKED_PAGE;  // 4096
```

**Sparse Array Paging**:
```cpp
auto assure_at_least(const entity_type entt) {
    const auto pos = entity_to_pos(entt);
    const auto page = pos_to_page(pos);  // pos / page_size

    if(!(page < sparse.size())) {
        // Allocate new pages
        const auto prev = sparse.size();
        sparse.resize(page + 1u, nullptr);

        for(auto curr = prev; curr < sparse.size(); ++curr) {
            sparse[curr] = alloc_traits::allocate(allocator, page_size);
            std::uninitialized_fill(sparse[curr], sparse[curr] + page_size, null);
        }
    }

    return sparse[page] + fast_mod(pos, page_size);
}
```

**Component Storage Paging**:
```cpp
auto assure_at_least(const std::size_t pos) {
    const auto idx = pos / traits_type::page_size;

    if(!(idx < payload.size())) {
        const auto prev = payload.size();
        payload.resize(idx + 1u, nullptr);

        for(auto curr = prev; curr < payload.size(); ++curr) {
            payload[curr] = alloc_traits::allocate(allocator, page_size);
        }
    }

    return payload[idx] + fast_mod(pos, page_size);
}
```

### Benefits of Paging

1. **Avoids large contiguous allocations**
   - 1M entities = 244 pages × 16KB = ~4MB (sparse)
   - Much easier to allocate than 4MB contiguous

2. **Grows incrementally**
   - Only allocate pages as needed
   - No upfront memory commitment

3. **Good cache behavior**
   - Within-page access is sequential
   - Page size = 4096 fits in L2 cache

4. **Stable pointers within page**
   - Elements don't move when pages added
   - Important for in_place deletion mode

### Memory Layout Example

```cpp
Position storage for 10,000 entities:

sparse: [page0*, page1*, page2*, nullptr, ...]
         │       │       │
         ▼       ▼       ▼
page0:  [0, 1, 2, ..., 4095]     (4096 indices)
page1:  [4096, 4097, ..., 8191]  (4096 indices)
page2:  [8192, 8193, ..., 9999]  (1808 indices used)

packed: [E0, E1, E2, ..., E9999]  (10,000 entities dense)

payload: [page0*, page1*, page2*, nullptr, ...]
          │       │       │
          ▼       ▼       ▼
page0:   [Pos0, Pos1, ..., Pos4095]    (4096 × sizeof(Position))
page1:   [Pos4096, ..., Pos8191]
page2:   [Pos8192, ..., Pos9999]

Total memory:
  - Sparse: 3 pages × 4096 × 4 bytes = 48KB
  - Packed: 10,000 × 4 bytes = 40KB
  - Payload: 3 pages × 4096 × sizeof(Position)
```

### Custom Allocators

EnTT fully supports custom allocators:

```cpp
template<typename Entity, typename Allocator>
class basic_registry {
    using alloc_traits = std::allocator_traits<Allocator>;
    using pool_allocator_type = typename alloc_traits::template rebind_alloc<...>;
};

// Usage
entt::basic_registry<entt::entity, MyCustomAllocator> registry;
```

**Allocator requirements**:
- Standard C++ allocator interface
- Used for all internal containers
- Propagated to pools and storages


---

## 10. COMPONENT TRAITS AND CUSTOMIZATION

### Component Traits System

```cpp
template<typename Type, typename = void>
struct component_traits {
    using type = Type;

    static constexpr bool in_place_delete = internal::in_place_delete<Type>::value;
    static constexpr std::size_t page_size = internal::page_size<Type>::value;
};
```

**Customization Points**:

1. **in_place_delete**: Force pointer stability
   - `true`: Use in_place deletion policy
   - `false`: Use swap_and_pop (default)

2. **page_size**: Override paging size
   - `0`: Zero-size component (tag)
   - `N`: Custom page size
   - `ENTT_PACKED_PAGE`: Default (4096)

### Trait Specialization

**Method 1: Member constants**:
```cpp
struct StableComponent {
    static constexpr bool in_place_delete = true;
    int value;
};

struct LargeComponent {
    static constexpr std::size_t page_size = 1024;
    std::array<float, 1000> data;
};

struct TagComponent {
    static constexpr std::size_t page_size = 0;
    // No data, just marker
};
```

**Method 2: Trait specialization**:
```cpp
template<>
struct entt::component_traits<MyComponent> {
    using type = MyComponent;
    static constexpr bool in_place_delete = true;
    static constexpr std::size_t page_size = 2048;
};
```

### Deletion Policy Selection

```cpp
// In basic_storage constructor
if constexpr(component_traits<Type>::in_place_delete) {
    basic_sparse_set::deletion_policy(entt::deletion_policy::in_place);
} else {
    basic_sparse_set::deletion_policy(entt::deletion_policy::swap_and_pop);
}
```

**Automatic based on traits**.


---

## 11. TYPE ERASURE TECHNIQUES

### Virtual Dispatch

**Base Class**:
```cpp
class basic_sparse_set {
protected:
    // Virtual interface for type-erased operations
    virtual void pop(basic_iterator first, basic_iterator last);
    virtual void pop_all();
    virtual basic_iterator try_emplace(const Entity entt, const bool force, const void *value);
    virtual const void *get_at(const std::size_t pos) const;
    virtual void swap_or_move([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs);
};
```

**Derived Implementation**:
```cpp
template<typename Type>
class basic_storage : public basic_sparse_set {
protected:
    void pop(basic_iterator first, basic_iterator last) override {
        // Type-specific component destruction
        for(; first != last; ++first) {
            auto &elem = element_at(index(*first));
            elem.~Type();
        }
        basic_sparse_set::pop(first, last);
    }
};
```

**Enables**:
```cpp
dense_map<id_type, std::shared_ptr<base_type>> pools;

// Destroy entity without knowing component types
for(auto &[id, pool] : pools) {
    if(pool->contains(entity)) {
        pool->remove(entity);  // Virtual dispatch
    }
}
```

### Type Info System

```cpp
const type_info *descriptor;  // Stored in basic_sparse_set
```

**Runtime type checking**:
```cpp
template<typename Type>
bool is_type() const noexcept {
    return descriptor == &type_id<Type>();
}
```

**Enables introspection** without RTTI.

### Signal System

```cpp
template<typename... Args>
class delegate {
    using fn_type = void(*)(const void *, Args...);

    const void *instance;
    fn_type fn;
};

template<typename... Args>
class sigh {
    std::vector<delegate<Args...>> calls;
};
```

**Type-erased callbacks** connected to component lifecycle:
```cpp
storage.on_construct().connect<&my_handler>();
storage.on_destroy().connect<&cleanup>();
```


---

## 12. SERIALIZATION SUPPORT

### Snapshot System (snapshot.hpp)

**Snapshot Creation**:
```cpp
template<typename Output>
class basic_snapshot {
    template<typename Type>
    const basic_snapshot &get(Output &archive) const {
        if(const auto *storage = reg->template storage<Type>(); storage) {
            // Write size
            archive(storage->size());

            // Write all entities + components
            for(auto elem : storage->reach()) {
                std::apply([&archive](auto &&...args) {
                    (archive(std::forward<decltype(args)>(args)), ...);
                }, elem);
            }
        }
        return *this;
    }
};
```

**Snapshot Loading**:
```cpp
template<typename Input>
class basic_snapshot_loader {
    template<typename Type>
    basic_snapshot_loader &get(Input &archive) {
        auto &storage = reg->template storage<Type>();
        typename traits_type::entity_type length{};
        archive(length);

        while(length--) {
            entity_type entt{};
            Type component{};
            archive(entt, component);
            storage.emplace(entt, std::move(component));
        }

        return *this;
    }
};
```

**Usage**:
```cpp
// Save
std::ofstream output("save.bin");
entt::snapshot{registry}
    .get<Position>(output)
    .get<Velocity>(output)
    .get<Health>(output);

// Load
std::ifstream input("save.bin");
entt::snapshot_loader{registry}
    .get<Position>(input)
    .get<Velocity>(input)
    .get<Health>(input);
```

**Features**:
- Archive agnostic (user provides serialization)
- Selective (choose which component types)
- Entity ID preservation
- Handles tombstones (in_place deletion)


---

## 13. SIGNAL SYSTEM

### Signal Architecture

```cpp
template<typename... Args>
class sigh {
private:
    std::vector<delegate<Args...>> calls;

public:
    template<auto Function, typename Type = std::decay_t<class_type_t<decltype(Function)>>>
    void connect(Type &value_or_instance) {
        calls.push_back(delegate<Args...>::template connect<Function>(value_or_instance));
    }

    void publish(Args... args) const {
        for(auto &call : calls) {
            call(args...);
        }
    }
};
```

### Component Lifecycle Signals

Every storage exposes signals:

```cpp
class basic_sparse_set {
public:
    [[nodiscard]] auto on_construct() noexcept { return sink{&construction}; }
    [[nodiscard]] auto on_update() noexcept { return sink{&update}; }
    [[nodiscard]] auto on_destroy() noexcept { return sink{&destruction}; }

private:
    signal_type construction;
    signal_type update;
    signal_type destruction;
};
```

### Signal Usage

**Connect handlers**:
```cpp
registry.on_construct<Position>().connect<&on_position_added>();
registry.on_destroy<Health>().connect<&on_death>();

void on_position_added(entt::registry &reg, entt::entity entity) {
    // React to Position component added
}

void on_death(entt::registry &reg, entt::entity entity) {
    // React to Health component removed
    reg.destroy(entity);
}
```

**Internal use (groups)**:
```cpp
void bind(basic_registry &reg) {
    pools[0u]->on_construct().connect<&group_handler::push_if>(*this);
    pools[0u]->on_destroy().connect<&group_handler::remove_if>(*this);
}
```

**Automatic signal emission**:
```cpp
template<typename... Args>
basic_iterator emplace(const Entity entt, Args &&...args) {
    auto it = /* ... construct component ... */;

    // Emit signal
    construction.publish(*this, entt);

    return it;
}
```


---

## 14. KEY DESIGN PATTERNS & DECISIONS

### 1. Sparse Set as Foundation

**Rationale**:
- O(1) insertion/removal without memory moves
- Dense iteration for cache locality
- Flexible entity composition
- No archetype transitions

**Trade-off**:
- Slower multi-pool iteration (vs archetypes)
- Mitigated by groups for hot paths

### 2. Paged Memory

**Rationale**:
- Avoid large contiguous allocations
- Grow incrementally
- Better than `std::deque` (pointer instability)
- Better than pure arrays (wasted memory)

**Trade-off**:
- Slight indirection cost
- More complex implementation

### 3. Groups as Optimization, Not Default

**Rationale**:
- Setup cost only paid when needed
- Views sufficient for most use cases
- Groups for performance-critical paths

**Philosophy**: "Pay for what you use"

### 4. Three Deletion Policies

**Rationale**:
- Different use cases need different guarantees
- `swap_and_pop`: Maximum performance
- `in_place`: Pointer stability
- `swap_only`: Internal (groups)

**Flexibility over dogma**

### 5. Signal-Based Reactivity

**Rationale**:
- Groups need to react to changes
- Users may want custom logic
- Decouples storage from observers

**Event-driven architecture**

### 6. Header-Only

**Rationale**:
- Zero library dependencies
- Compile-time optimization
- Template specialization

**Trade-off**: Longer compile times

### 7. Type Erasure with Virtual Dispatch

**Rationale**:
- Registry can't know all component types at compile time
- Virtual dispatch for common operations
- Templates for user-facing API

**Hybrid approach**: Templates + polymorphism


---

## 15. PERFORMANCE CHARACTERISTICS

### Operation Complexity

| Operation | EnTT (Sparse Set) | Bevy (Archetype) |
|-----------|-------------------|------------------|
| **Create Entity** | O(1) | O(1) |
| **Destroy Entity** | O(C) iterate pools | O(1) but copies memory |
| **Add Component** | O(1) no moves | O(N) archetype transition |
| **Remove Component** | O(1) no moves | O(N) archetype transition |
| **Iterate View** | O(N × M) multi-pool | O(N) table scan |
| **Iterate Group** | O(N) cached | O(N) table scan |
| **Random Access** | O(1) sparse lookup | O(1) sparse lookup |
| **Group Setup** | O(N) scan entities | O(A) match archetypes |

**Where**:
- N = number of entities
- C = number of component types in registry
- M = number of component types in query
- A = number of archetypes

### Best Use Cases

**EnTT excels at**:
- Dynamic entity composition (add/remove components frequently)
- Sparse component distribution (few entities have each component)
- Large number of component types
- Prototyping and iteration

**Archetypes excel at**:
- Stable entity composition (few component changes)
- Dense component distribution (most entities have same components)
- Smaller number of component types
- Known query patterns


---

## 16. COMPARISON: EnTT vs Bevy ECS

| Aspect | EnTT (Sparse Set) | Bevy (Archetype) |
|--------|-------------------|------------------|
| **Core Structure** | One sparse set per component | Tables per archetype |
| **Component Add/Remove** | O(1) - no entity moves | O(N) - entity moves between tables |
| **Iteration** | Multi-pool traversal (slow) | Table scan (fast) |
| **Iteration (Optimized)** | Groups provide SoA | Archetypes inherently SoA |
| **Memory Layout** | Paged per component | Paged per archetype |
| **Fragmentation** | Possible with in_place | Minimal (compacted) |
| **Query Setup** | O(1) view, O(N) group | O(A) archetype matching |
| **Structural Changes** | Fast (no moves) | Slow (copies all components) |
| **Change Detection** | Manual/signals | Automatic tick-based |
| **Best For** | Dynamic composition | Stable composition |

### Philosophical Differences

**EnTT**:
- Component-centric (one storage per type)
- Optimization via groups (explicit)
- Flexibility over structure
- "Pay only for what you use"

**Bevy**:
- Entity-centric (archetype grouping)
- Optimization via archetypes (implicit)
- Structure over flexibility
- "Fast iteration by default"


---

## 17. TRANSLATION TO SWIFT FOR IKYO

### Key Considerations

#### 1. Sparse Set Implementation

**Challenge**: Paged arrays in Swift
**Solution**:
```swift
struct SparseSet<Entity: EntityType> {
    // Paged sparse array
    var sparse: [UnsafeMutablePointer<Int32>?]

    // Dense entity array
    var packed: ContiguousArray<Entity>

    // Deletion mode
    var mode: DeletionPolicy
}
```

**Use `ContiguousArray` for packed** (guaranteed contiguous).

#### 2. Component Storage

**Challenge**: Type-erased paged storage
**Solution**:
```swift
protocol ComponentStorage: AnyObject {
    func remove(_ entity: Entity)
    func contains(_ entity: Entity) -> Bool
}

final class Storage<T: Component>: SparseSet, ComponentStorage {
    // Paged component storage
    var payload: [UnsafeMutablePointer<T>?]

    func get(_ entity: Entity) -> T? {
        guard let index = self.index(entity) else { return nil }
        let page = index / pageSize
        let offset = index % pageSize
        return payload[page]?[offset]
    }
}
```

**Use protocols for type erasure**.

#### 3. Registry

**Challenge**: Type-safe pool access
**Solution**:
```swift
final class Registry {
    // Type-erased storage map
    private var pools: [ObjectIdentifier: any ComponentStorage] = [:]

    func storage<T: Component>() -> Storage<T> {
        let id = ObjectIdentifier(T.self)
        if let existing = pools[id] as? Storage<T> {
            return existing
        }
        let storage = Storage<T>()
        pools[id] = storage
        return storage
    }
}
```

**Use `ObjectIdentifier` for type IDs**.

#### 4. Views

**Challenge**: Multi-pool iteration
**Solution**:
```swift
struct View<D: QueryData> {
    var pools: [any ComponentStorage]
    var leadIndex: Int

    func each() -> ViewIterator<D> {
        // Iterate lead pool with filtering
    }
}
```

**Generic over `QueryData` protocol**.

#### 5. Groups

**Challenge**: Signal-based cache maintenance
**Solution**:
```swift
final class GroupHandler {
    var pools: [any ComponentStorage]
    var length: Int = 0

    func onConstruct(_ entity: Entity) {
        // Check criteria and swap if matches
    }
}

// Connect to storage
storage.onConstruct.append { [weak handler] entity in
    handler?.onConstruct(entity)
}
```

**Use Combine or custom closures for signals**.

#### 6. Memory Management

**Challenge**: Manual paged allocation
**Solution**:
```swift
final class PagedArray<T> {
    private var pages: [UnsafeMutablePointer<T>?] = []
    private let pageSize: Int = 4096

    func ensureCapacity(_ index: Int) {
        let page = index / pageSize
        while pages.count <= page {
            let ptr = UnsafeMutablePointer<T>.allocate(capacity: pageSize)
            pages.append(ptr)
        }
    }

    deinit {
        for page in pages {
            page?.deallocate()
        }
    }
}
```

**Use `UnsafeMutablePointer` for manual allocation**.

### Recommended Implementation Approach

**Phase 1: Core Foundation**
1. Implement `Entity` type (UInt32/UInt64 with version)
2. Build `SparseSet` with swap_and_pop deletion
3. Create `Storage<T>` inheriting from SparseSet
4. Build `Registry` with type-erased pools

**Phase 2: Query System**
1. Implement single-component views
2. Add multi-component views with lead pool
3. Support exclusion filters

**Phase 3: Optimization**
1. Add owning groups
2. Implement signal system
3. Support pointer stability (in_place deletion)

**Phase 4: Advanced Features**
1. Non-owning groups
2. Serialization support
3. Custom allocators

### Swift-Specific Optimizations

1. **Use value types for components**
   - Avoid ARC overhead
   - Better cache locality

2. **Leverage copy-on-write**
   - Share pages between storages if needed
   - Optimize group partitioning

3. **Protocol witnesses over existentials**
   - Specialize hot paths
   - Avoid protocol dispatch in iteration

4. **@inlinable for critical paths**
   - `contains()`, `index()`, `get()`
   - Iterator advancement

5. **UnsafePointer for tight loops**
   - Direct memory access in iteration
   - Avoid bounds checking

### Example: Basic Implementation

```swift
// Entity
struct Entity: Hashable {
    var raw: UInt32

    var index: UInt32 { raw & 0xFFFFF }
    var version: UInt32 { raw >> 20 }
}

// Component protocol
protocol Component {
    static var pageSize: Int { get }
}

extension Component {
    static var pageSize: Int { 4096 }
}

// Sparse set
final class SparseSet<E: Hashable> {
    private var sparse: [UnsafeMutablePointer<Int32>?] = []
    private var packed: ContiguousArray<E> = []

    func push(_ entity: E) {
        // ... ensure sparse page ...
        packed.append(entity)
        // ... update sparse ...
    }
}

// Storage
final class Storage<T: Component>: SparseSet<Entity> {
    private var payload: [UnsafeMutablePointer<T>?] = []

    func emplace(_ entity: Entity, _ component: T) {
        // ... allocate page if needed ...
        let index = packed.count
        let page = index / T.pageSize
        let offset = index % T.pageSize
        payload[page]![offset] = component
        push(entity)
    }
}

// Registry
final class Registry {
    private var pools: [ObjectIdentifier: AnyObject] = [:]

    func storage<T: Component>() -> Storage<T> {
        let id = ObjectIdentifier(T.self)
        if let existing = pools[id] as? Storage<T> {
            return existing
        }
        let storage = Storage<T>()
        pools[id] = storage
        return storage
    }

    func emplace<T: Component>(_ entity: Entity, _ component: T) {
        storage<T>().emplace(entity, component)
    }
}
```


---

## 18. SUMMARY

### Architecture
- **Pure sparse-set based**: One sparse set per component type
- **Paged memory**: Avoids large contiguous allocations
- **Type erasure**: Virtual dispatch for common operations
- **Signal-driven**: Reactive updates for groups

### Entities
- **Generational indices**: 20/32-bit index + 12/32-bit version
- **Recycling**: Free list for entity ID reuse
- **Flexible**: No archetype constraints

### Components
- **Paged storage**: 4096 components per page (default)
- **Parallel to sparse set**: Component index matches entity index
- **Empty optimization**: Zero-size types have no storage
- **Customizable**: Page size and deletion policy

### Queries
- **Views**: Cheap, temporary, multi-pool iteration
- **Groups**: Cached, perfect SoA for owned components
- **Lead pool**: Iterate smallest pool for efficiency
- **Signals**: Automatic cache maintenance

### Performance
- **Fast structural changes**: O(1) add/remove components
- **Fast random access**: O(1) via sparse array
- **Groups for iteration**: O(N) with perfect SoA
- **Views for flexibility**: O(N × M) but zero setup

### Design Philosophy
1. **Pay for what you use** (views cheap, groups optimized)
2. **Flexibility over dogma** (multiple deletion policies)
3. **Performance through specialization** (groups for hot paths)
4. **Modern C++ idioms** (templates, type erasure, signals)

### Swift Translation
- Use `UnsafeMutablePointer` for paging
- Protocol existentials for type erasure
- `ContiguousArray` for dense storage
- Manual memory management for performance
- Consider EngineBuffer integration

### Best Use Cases
- Dynamic entity composition
- High component add/remove frequency
- Sparse component distribution
- Prototyping and iteration
- **Minecraft uses it!** (proven at massive scale)

This sparse-set architecture offers excellent trade-offs for Ikyo's ray marching engine, especially if entity compositions change frequently or components are sparsely distributed.
