Based on this Ikyo game engine codebase, design a high-performance ECS (Entity Component System) architecture that fits the existing structure and philosophy.

Requirements:

Follow the monolithic architecture philosophy (no plugins, integrated)
Use the existing custom memory allocators (BinnedAllocator, LargeAllocator, Arena)
Optimize for SVOGI (voxel cone tracing) + SVO-DDA ray marching rendering workload
Maximum performance - leverage Swift's generics and avoid protocol existentials in hot paths
Design for DOD (Data-Oriented Design) principles
Consider that this is a SVOGI + ray marching renderer (not traditional rasterization)

Please provide:

Complete ECS architecture design (sparse-set vs archetype recommendation)
Concrete code structure and file organization
Integration points with existing memory system
How to structure components, systems, and queries for SVOGI + ray marching workloads
Performance-critical considerations specific to this codebase



----

Below is a concrete ECS design for Ikyo that stays monolithic, uses your allocators directly, and is tuned for SVOGI (Sparse Voxel Octree Global Illumination) + SVO-DDA ray marching renderer and Swift performance characteristics. It prioritizes SoA layout, generics-only APIs, and avoiding ARC and protocol existentials in hot paths.

Architecture: hybrid sparse-set with cached views (SoA), not archetypes

Rationale:

SVOGI + ray marching traverses a known set of components (Transform + Voxelizable/Mesh + Material + Bounds + Lights). The set of commonly queried component combinations is fixed and small.
Sparse-set storages yield O(1) add/remove, stable contiguous iteration order, and no wholesale row moves on composition changes (unlike archetypes).
We retain cache-friendly dense arrays per component (SoA). Queries intersect dense arrays once and then stream the result every frame.
We add precomputed "views" (cached intersections) for hot combinations (e.g., Renderable + Voxelizable + Transform + Material) to eliminate repeated set intersections per frame. These "views" are rebuilt incrementally on add/remove or lazily per frame using FrameArena.
Archetypes are overkill here and introduce fragmentation, higher mutation costs, and complexity that does not benefit a monolithic, fixed-system renderer.

Core design:

Entity = 32-bit packed ID (index: 24 bits, generation: 8 bits). Generations prevent ABA reuse. Free-list for reuse.
ComponentStorage: packed sparse-set with:

denseEntities: EngineBuffer<Entity>
dense: EngineBuffer<T> (aligned to 64 bytes)
sparse: paged or flat EngineBuffer mapping entityIndex -> denseIndex (or -1)
size/capacity with manual grow using LargeAllocator (via EngineBuffer).
Add/Remove/Has/Get Unsafe pointer APIs for hot paths, no existential/protocol machinery.

Query views:

Small fixed structs that hold precomputed dense index lists for specific combinations, rebuilt when marked dirty.
Store view membership bitset/tagged bloom for quick incremental invalidation if desired (optional).

Systems are plain functions parametrized over storages. No protocol System. Keep hot loops monomorphic.

Rendering Pipeline Overview

G-Buffer: SVO-DDA ray marching (Primary visibility)
  └─ Sparse Voxel Octree traversal
  └─ 3D-DDA for voxel traversal
  └─ Extract Normal, Material ID, Depth

GI: SVOGI Cone Tracing
  └─ Diffuse indirect lighting
  └─ Ambient occlusion

Mirror Reflection: SVO-DDA ray marching
  └─ Ray march in reflection vector direction
  └─ 1-2 bounce limit
  └─ Fast traversal via SVO hierarchy

Glossy Reflection: Cone Tracing (additional optimization)
  └─ Approximate non-perfect mirror with cone
  └─ Adjust cone angle based on roughness

Transparent/Refraction: SVO-DDA ray marching
  └─ Ray march after computing refraction vector
  └─ Beer's law for attenuation
  └─ Volume representation via voxel density

Shadow: SVO-DDA ray marching
  └─ Ray march toward light source
  └─ Early termination (stop at first hit)
  └─ Soft shadow via cone tracing

Concrete code structure and file organization

ecs/Entity.swift

Entity (UInt32 id), EntityManager with generations, freelist, capacity management.

ecs/storage/PackedSparseSet.swift

struct PackedSparseSet<T> { … } using EngineBuffer, EngineBuffer, EngineBuffer
inline add/remove/has/get/forEach

ecs/World.swift

final class World { entities, and concrete storages:

transforms: PackedSparseSet<Transform>
materials: PackedSparseSet<MaterialPBR>
renderable: PackedSparseSet<TagRenderable> (tag = Empty struct)
voxelizable: PackedSparseSet<TagVoxelizable>
bounds: PackedSparseSet<BoundsAABB> or BoundsSphere
meshRef: PackedSparseSet<MeshRef>
transparent: PackedSparseSet<Transparent>
lightDirectional: PackedSparseSet<LightDirectional>
lightPoint: PackedSparseSet<LightPoint>
lightSpot: PackedSparseSet<LightSpot>
voxelizeDirty: PackedSparseSet<VoxelizeDirty> (tag)
tagDynamic: PackedSparseSet<TagDynamic>
optional: sdfSphere/sdfBox/sdfCapsule (legacy SDF support)
cached views (structs), dirty flags
per-frame frameArena: FrameArena
svoScene: SVOScene (double-buffered)
svogi: SVOGIState
gbuffer: GBufferTargets
}

ecs/Query.swift

functions to build views for (Renderable + Voxelizable + Transform + Material), etc.; return arrays of dense indices using FrameArena.

ecs/Systems/*

Spawn/Destroy/Attach components
TransformSystem (optional hierarchy: precompute world transforms)
BoundsSystem (compute/update BoundsAABB or BoundsSphere from Transform + mesh/SDF)
ChangeTrackingSystem (mark VoxelizeDirty on Transform/Material change)
BuildSVOSystem (compile ECS to SVO, incremental or full rebuild)
BuildSVOMipsSystem (generate lower mip levels for cone tracing)
LightInjectionSystem (inject radiance from lights into SVO)

render/svo/SVOScene.swift

struct SVOScene {
    nodes: EngineBuffer<Node>           // Octree node array
    leaves: EngineBuffer<Leaf>          // Leaf indexing
    leafAlbedo: EngineBuffer<UInt32>    // Packed albedo/opacity/metalness/roughness/emissive
    leafNormal: EngineBuffer<UInt32>    // Optional: packed bidirectional/average normals
    mipOffsets: EngineBuffer<Int>       // MIP chain for cone tracing
    levelInfo: EngineBuffer<LevelInfo>
    nodeCount, leafCount, levels, resolution: Int
    doubleBuffered: Bool                // Build-render double buffering
}

render/svo/SVOBuildSystems.swift

BuildSVOSystem(world: World) -> SVOScene
BuildSVOMipsSystem(world: World, scene: inout SVOScene)
LightInjectionSystem(world: World, scene: inout SVOScene)

render/svogi/SVOGISystems.swift

SVOGIConeTraceSystem(world: World, scene: SVOScene, gbuffer: GBufferTargets)

render/passes/GBufferSVOPass.swift

GBufferSVOPass(world: World, scene: SVOScene) -> GBufferTargets

render/passes/ReflectionPass.swift

ReflectionPass(world: World, scene: SVOScene, gbuffer: GBufferTargets)

render/passes/TransparentPass.swift

TransparentPass(world: World, scene: SVOScene, gbuffer: GBufferTargets)

render/passes/ShadowPass.swift

ShadowPass(world: World, scene: SVOScene, gbuffer: GBufferTargets)

memory integration is already provided in Allocator.swift, BinnedAllocator.swift, LargeAllocator.swift, Arena.swift

Integration with the existing memory system

Persistent storages:

Use EngineBuffer<T> internally for dense arrays. EngineBuffer already routes small to BinnedAllocator and >4KB to LargeAllocator. Specify alignment = max(64, MemoryLayout<T>.alignment) for cache line alignment in SoA buffers.
PackedSparseSet's metadata (counts, capacities, simple arrays < 4KB) naturally go through BinnedAllocator.
SVOScene and SVOGIState (large buffers, MB~hundreds of MB): use LargeAllocator via EngineBuffer. Consider vmAdviseHuge(region, enable: true) on Linux for TLB reduction.

Frame-temporary data:

Use FrameArena for:

Query intersections and temporary lists
Per-frame view rebuilds (dense index arrays)
SVO build scratch buffers (insertion buffers, leaf temporary lists, sort arrays)
Tile candidate lists for ray marching

world.endFrame():

BinnedAllocator.shared.flushTLS()
frameArena.endFrame()

Large CPU working sets (SVO build/mip generation):

Allocate big per-frame arrays out of FrameArena so they reset cheaply; avoid ARC containers in hot paths.
Double-buffer SVOScene: buildBuffer (write) and renderBuffer (read) swap.

Components, systems, and queries tuned for SVOGI + ray marching

Components (POD-only; no ARC members):

Transform: position (SIMD3<Float>), rotation (simd_quatf), scale (SIMD3<Float>). Size ~48–64B.
  - Start as AoS; split into Position/Rotation/Scale SoA only if profiling demands.
MaterialPBR: baseColor (SIMD3<Float>), emissive (SIMD3<Float>), roughness (Float), metalness (Float), opacity (Float).
  - Voxelization packs albedo/opacity/metalness/roughness/emissive into UInt32 or packed formats.
TagRenderable: Empty struct (tag).
TagVoxelizable: Empty struct (mark for SVO voxelization).
TagDynamic: Empty struct (frequently changing, candidate for incremental revoxelization).
BoundsAABB: min (SIMD3<Float>), max (SIMD3<Float>) OR BoundsSphere { center: SIMD3<Float>, radius: Float }
  - For coarse culling and conservative SVO bound.
MeshRef: id (UInt32) - handle to mesh (actual vertex/index in separate resource).
LightDirectional: direction (SIMD3<Float>), color (SIMD3<Float>), intensity (Float).
LightPoint: position (SIMD3<Float>), color (SIMD3<Float>), intensity (Float), range (Float).
LightSpot: position (SIMD3<Float>), direction (SIMD3<Float>), color (SIMD3<Float>), intensity (Float), innerAngle (Float), outerAngle (Float), range (Float).
VoxelizeDirty: Empty struct (tag for change tracking).
Transparent: ior (Float), absorption (SIMD3<Float>) - refraction/Beer's law parameters.
Optional (legacy): SDFSphere { radius: Float }, SDFBox { halfExtents: SIMD3<Float>, round: Float }, SDFCapsule { … }
  - Can be voxelized into SVO if needed (implicit→voxel).

Guideline: Avoid polymorphism. Each component type has its own storage (SoA). Systems do per-type loops.

Systems:

TransformSystem (optional hierarchy): precompute world transforms if you have parents. Store only final transform in Transform to keep hot loops simple.
BoundsSystem: compute/update BoundsAABB or BoundsSphere from Transform + mesh/SDF parameters (SoA, strided).
ChangeTrackingSystem:
  - Mark VoxelizeDirty on Transform/Material change.
  - Simple tag-based approach (no complex tick system initially).
BuildSVOSystem:
  - Inputs: VoxelizeView (Renderable + Voxelizable + Transform + MaterialPBR ± MeshRef/SDF*)
  - Policy:
    - If dirty count/ratio below threshold: incremental update (revoxelize only dirty leaves).
    - If threshold exceeded: full rebuild (fast path, double buffer).
  - Output: SVOScene with nodes, leaves, leaf attributes via LargeAllocator.
  - Scratch: FrameArena for insertion buffers, leaf temporary lists, sort arrays.
BuildSVOMipsSystem:
  - Aggregate SVO leaf/brick into lower mips (Level-of-Detail) for cone tracing.
LightInjectionSystem:
  - Traverse LightView (Directional/Point/Spot) and inject radiance into SVO (Direct), optional multi-bounce warm-up.
GBufferSVOPass:
  - SVO-DDA for primary visibility → G-Buffer (Normal, Material ID, Depth).
SVOGIConeTraceSystem:
  - G-Buffer based cone tracing, compute AO/indirect lighting (use radiance/normal mips).
ReflectionPass:
  - Mirror: SVO-DDA ray marching (1–2 bounce limit).
  - Glossy: roughness-based cone tracing.
TransparentPass:
  - Compute refraction vector, SVO-DDA ray march, Beer's law attenuation.
ShadowPass:
  - SVO-DDA ray march toward light, early termination; soft shadow via cone approximation.

Queries:

Use cached "views" for common intersections. Examples:
  - VoxelizeView: Renderable + Voxelizable + Transform + MaterialPBR (± MeshRef/SDF*)
  - DynamicVoxelizeView: above + TagDynamic
  - LightView (per type): LightDirectional/Point/Spot
  - TransparentView: Renderable + Transparent + Transform + MaterialPBR

Each storage has a denseEntities array. Build an intersection by picking the smallest dense set (e.g., voxelizable) and checking membership in the others via sparse indices.
Cache these entity lists (EngineBuffer<Int32>) in World for reuse in the same frame. Mark dirty on add/remove in any of the involved storages.


Performance-critical considerations specific to Ikyo + Swift + SVOGI + ray marching

Avoid ARC and existentials:

All components are POD structs. No class references or closures captured in hot loops.
No protocol Component or System in hot paths. Use generic functions on concrete types.

Prefer monomorphic hot loops:

Separate loops per component type for voxelization/tracing; no switch-per-element inside the loop.
@inlinable and @inline(__always) on tight loops and accessors for specialization.

SoA and alignment:

Use EngineBuffer with alignment >= 64 for dense arrays.
For transforms/materials, the component itself is an AoS record; this is okay if you access them together. If you access individual fields independently, split them into separate SoA storages (e.g., Position, Rotation, Scale). Start with AoS Transform and split only if profiling demands it.

Bounds-first:

Maintain BoundsAABB or BoundsSphere for each instance; test bound during tracing to generate a per-ray candidate set early.
SVO traversal also uses childMask for fast rejection.

Memory/tooling integration:

End-of-frame: FrameArena.reset + BinnedAllocator.flushTLS
EngineBuffer clean dealloc goes through allocator with exact sizes.
For very large read-mostly arrays (e.g., SVO node/leaf buffers), consider vmAdviseHuge(region, enable: true) on Linux to reduce TLB misses (optional).

Swift micro-optimizations:

Access withUnsafeMutableBufferPointer to remove bounds checks in loops.
Prefer while loops with pointer bumping over for-in when truly hot.
Avoid capturing closures in tight loops; provide manual loop functions.
Mark storages and world final and internal functions @inlinable for cross-file inlining (since monolithic).

Threading:

Partition SVO builds by spatial region/node range across threads, each thread writing to its own FrameArena sub-alloc (or pre-slice the output arrays). Concatenate ranges after.
Be careful not to share EngineBuffer across threads mutably without partitioning. Cone tracing per-tile can be trivially parallel.

SVO-specific:

Pack leaf albedo/normal/radiance (e.g., packed RGBA16F or 10-bit formats into UInt32) to reduce bandwidth in the tracing loop.
Use FrameArena for all transient arrays and candidate lists; no ARC, no retain/release.
Put @inlinable and @inline(__always) on:
  - PackedSparseSet.getPtr/add/remove/has
  - Query builders
  - SVO-DDA traversal and distance/cone evaluators

Key structs and APIs (concise sketches)

ecs/Entity.swift
struct Entity { var raw: UInt32 } // 24-bit index, 8-bit gen
@inline(__always) func entityIndex(_ e: Entity) -> Int { Int(e.raw & 0x00FF_FFFF) }
@inline(__always) func entityGen(_ e: Entity) -> UInt8 { UInt8((e.raw >> 24) & 0xFF) }

final class EntityManager {
    private var generations: EngineBuffer<UInt8>
    private var freeList: [UInt32] = []
    private(set) var capacity: Int
    init(initial: Int = 8192) { ... allocate generations via EngineBuffer ... }
    func create() -> Entity { ... }
    func destroy(_ e: Entity) { ... bump gen, push index to freeList ... }
    @inline(__always) func alive(_ e: Entity) -> Bool { generations[eIndex] == eGen }
}

ecs/storage/PackedSparseSet.swift
struct PackedSparseSet<T> {
    // SoA: dense values and dense->entity mapping
    private var values: EngineBuffer<T>
    private var entities: EngineBuffer<Entity>
    // sparse maps entityIndex -> denseIndex+1 (0 means empty), keeps array small and branchless
    private var sparse: EngineBuffer<Int32>
    private(set) var count: Int
    private var capacity: Int

    init(initialCapacity: Int = 1024, align: Int = 64) { ... values = EngineBuffer(count: initialCapacity, alignment: align) ... }
    mutating func ensureCapacity(_ n: Int) { ... grow all three buffers (values/entities/sparse) using LargeAllocator via EngineBuffer ... }
    @inline(__always) func has(_ e: Entity) -> Bool { let i = entityIndex(e); return i < sparse.count && sparse[i] != 0 }
    @inline(__always) mutating func add(_ e: Entity, _ v: T) { ... push back into dense; update sparse[entityIndex]=denseIndex+1 }
    @inline(__always) mutating func remove(_ e: Entity) { ... swap-remove from dense; update sparse; maintain entities[] }
    @inline(__always) func getPtr(_ e: Entity) -> UnsafeMutablePointer<T>? { ... return &values.bufferPointer[denseIndex] }
    @inline(__always) func forEach(_ body: (UnsafeMutablePointer<T>, Entity) -> Void) { // monomorphic loop
        let vp = values.bufferPointer
        let ep = entities.bufferPointer
        var i = 0
        while i < count {
            body(vp.advanced(by: i), ep.advanced(by: i).pointee)
            i &+= 1
        }
    }
}

ecs/World.swift
struct Transform { var pos: SIMD3<Float>; var rot: simd_quatf; var scl: SIMD3<Float> }
struct MaterialPBR { var base: SIMD3<Float>; var emissive: SIMD3<Float>; var roughness: Float; var metalness: Float; var opacity: Float }
struct TagRenderable {}
struct TagVoxelizable {}
struct TagDynamic {}
struct VoxelizeDirty {}
struct BoundsAABB { var min: SIMD3<Float>; var max: SIMD3<Float> }
struct MeshRef { var id: UInt32 }
struct LightDirectional { var dir: SIMD3<Float>; var color: SIMD3<Float>; var intensity: Float }
struct LightPoint { var pos: SIMD3<Float>; var color: SIMD3<Float>; var intensity: Float; var range: Float }
struct LightSpot { var pos: SIMD3<Float>; var dir: SIMD3<Float>; var color: SIMD3<Float>; var intensity: Float; var inner: Float; var outer: Float; var range: Float }
struct Transparent { var ior: Float; var absorption: SIMD3<Float> }
// Optional legacy SDF
struct SDFSphere { var radius: Float }
struct SDFBox { var halfExtents: SIMD3<Float>; var round: Float }

struct VoxelizeView { var indices: EngineBuffer<Int32> } // dense indices into voxelizable storage; built per frame in arena
struct DynamicVoxelizeView { var indices: EngineBuffer<Int32> }
struct LightViewDirectional { var indices: EngineBuffer<Int32> }
// Similarly for Point/Spot

final class World {
    let entities = EntityManager(initial: 65536)
    var transforms = PackedSparseSet<Transform>()
    var materials = PackedSparseSet<MaterialPBR>()
    var renderable = PackedSparseSet<TagRenderable>()
    var voxelizable = PackedSparseSet<TagVoxelizable>()
    var bounds = PackedSparseSet<BoundsAABB>()
    var meshRef = PackedSparseSet<MeshRef>()
    var transparent = PackedSparseSet<Transparent>()
    var lightDirectional = PackedSparseSet<LightDirectional>()
    var lightPoint = PackedSparseSet<LightPoint>()
    var lightSpot = PackedSparseSet<LightSpot>()
    var voxelizeDirty = PackedSparseSet<VoxelizeDirty>()
    var tagDynamic = PackedSparseSet<TagDynamic>()
    // Optional legacy SDF
    var sdfSphere = PackedSparseSet<SDFSphere>()
    var sdfBox = PackedSparseSet<SDFBox>()
    
    // Cached views (recreated per frame into FrameArena or marked dirty)
    var viewVoxelizeCountDirty = true
    var viewDynamicVoxelizeCountDirty = true
    var viewLightsDirectionalCountDirty = true
    // ... etc
    
    // Per-frame arena
    private let frameArena = FrameArena(reserveSize: 64 * 1024 * 1024)!
    
    // SVO resources
    var svoScene: SVOScene
    var svogi: SVOGIState
    var gbuffer: GBufferTargets
    
    func beginFrame() { /* mark views dirty if you track structural changes lazily */ }
    func endFrame() {
        BinnedAllocator.shared.flushTLS()
        frameArena.endFrame()
    }
    func arena() -> FrameArena { frameArena }
}

ecs/Query.swift
@inline(__always)
func buildVoxelizeView(world: World, arena: FrameArena) -> VoxelizeView {
    let srcCount = world.voxelizable.count
    let out = EngineBuffer<Int32>(count: srcCount, alignment: 64, allocator: IkyoAlloc.global)!
    let outPtr = out.bufferPointer
    let entPtr = world.voxelizable.entities.bufferPointer
    var outCount = 0
    var i = 0
    while i < srcCount {
        let e = entPtr.advanced(by: i).pointee
        if world.renderable.has(e) && world.transforms.has(e) && world.materials.has(e) {
            outPtr.advanced(by: outCount).pointee = Int32(i)
            outCount &+= 1
        }
        i &+= 1
    }
    // shrink-if-needed (optional) or just store count separately
    return VoxelizeView(indices: out /* keep count separately if desired */)
}

render/svo/SVOScene.swift
struct Node {
    var childMask: UInt8      // 8-bit mask for 8 children
    var firstChild: UInt32    // Index into nodes array for first child
}
struct Leaf {
    var colorIdx: UInt32      // Index into leafAlbedo
    var normalIdx: UInt32     // Index into leafNormal
    var opacity: UInt16
    var flags: UInt16
}
struct LevelInfo {
    var offset: Int
    var count: Int
}
struct SVOScene {
    var nodes: EngineBuffer<Node>
    var leaves: EngineBuffer<Leaf>
    var leafAlbedo: EngineBuffer<UInt32>   // Packed albedo/opacity/metalness/roughness/emissive
    var leafNormal: EngineBuffer<UInt32>   // Packed bidirectional/average normals
    var mipOffsets: EngineBuffer<Int>
    var levelInfo: EngineBuffer<LevelInfo>
    var nodeCount: Int
    var leafCount: Int
    var levels: Int
    var resolution: Int
    var doubleBuffered: Bool
}

render/svo/SVOBuildSystems.swift
func buildSVOSystem(world: World) -> SVOScene {
    let arena = world.arena()
    // Build voxelize view
    let view = buildVoxelizeView(world: world, arena: arena)
    
    // Allocate SVO buffers (LargeAllocator via EngineBuffer)
    // ... voxelization logic (transform mesh/SDF into occupancy grid, build octree) ...
    // ... use FrameArena for scratch buffers ...
    
    // Return populated SVOScene
    return SVOScene(
        nodes: nodes,
        leaves: leaves,
        leafAlbedo: albedo,
        leafNormal: normals,
        mipOffsets: mipOffsets,
        levelInfo: levelInfo,
        nodeCount: nodeCount,
        leafCount: leafCount,
        levels: levels,
        resolution: resolution,
        doubleBuffered: true
    )
}

func buildSVOMipsSystem(world: World, scene: inout SVOScene) {
    // Aggregate leaf/brick into lower mips (Level-of-Detail) for cone tracing
    // ... implementation ...
}

func lightInjectionSystem(world: World, scene: inout SVOScene) {
    // Traverse light views and inject radiance into SVO
    let lightDirView = buildLightDirectionalView(world: world, arena: world.arena())
    // ... inject direct light into radiance field ...
}

render/svogi/SVOGISystems.swift
struct SVOGIState {
    var radiance: EngineBuffer<UInt32>  // Per-leaf/brick radiance (or per mip level)
    var temporalHistory: EngineBuffer<UInt32>?  // Optional: previous frame accumulation/reprojection
    var coneParams: ConeParams
}

struct ConeParams {
    var numCones: Int
    var angles: [Float]
    var steps: [Int]
    // ... etc
}

func svogiConeTraceSystem(world: World, scene: SVOScene, gbuffer: GBufferTargets) {
    // G-Buffer based cone tracing, compute AO/indirect lighting
    // Use radiance/normal mips
    // ... implementation ...
}

render/passes/GBufferSVOPass.swift
struct GBufferTargets {
    var normal: /* handle/pointer */
    var materialID: /* handle/pointer */
    var depth: /* handle/pointer */
}

func gBufferSVOPass(world: World, scene: SVOScene) -> GBufferTargets {
    // SVO-DDA for primary visibility → G-Buffer (Normal, Material ID, Depth)
    // ... implementation ...
    return GBufferTargets(...)
}

render/passes/ReflectionPass.swift
func reflectionPass(world: World, scene: SVOScene, gbuffer: GBufferTargets) {
    // Mirror: SVO-DDA ray marching (1–2 bounce limit)
    // Glossy: roughness-based cone tracing
    // ... implementation ...
}

render/passes/TransparentPass.swift
func transparentPass(world: World, scene: SVOScene, gbuffer: GBufferTargets) {
    // Compute refraction vector, SVO-DDA ray march, Beer's law attenuation
    let view = buildTransparentView(world: world, arena: world.arena())
    // ... implementation ...
}

render/passes/ShadowPass.swift
func shadowPass(world: World, scene: SVOScene, gbuffer: GBufferTargets) {
    // SVO-DDA ray march toward light, early termination
    // Soft shadow via cone approximation
    // ... implementation ...
}

Performance notes on the SVOGI + SVO-DDA path

Group by component type and run type-specialized loops. This avoids runtime switching and improves branch prediction.
Keep per-ray candidate lists tiny:

Use BoundsAABB/BoundsSphere plus SVO hierarchy (childMask) to preselect candidates per pixel tile or ray packet.

Evaluate transforms minimally:

Either bake the transform into the SVO at build time (preferred for static geometry), or keep transforms separate but contiguous and prefetch them.

Keep data hot and packed:

Pack leaf albedo/normal/radiance data tightly (e.g., packed RGBA16F or 10-bit formats into UInt32) to reduce bandwidth in the tracing loop.

Use FrameArena for all transient arrays and candidate lists; no ARC, no retain/release.
Put @inlinable and @inline(__always) on:

PackedSparseSet.getPtr/add/remove/has
Query builders
SVO-DDA traversal and cone evaluators for each component type

SVO memory management:

SVOScene and SVOGIState use LargeAllocator (MB~hundreds of MB).
Consider vmAdviseHuge(region, enable: true) on Linux for TLB reduction.
Double-buffer: buildBuffer (write) and renderBuffer (read) swap to avoid read-write conflicts during incremental rebuild.

Incremental voxelization:

Track dirty entities (VoxelizeDirty tag).
If dirty count/ratio below threshold (e.g., 5–10%): revoxelize only dirty leaves.
If threshold exceeded: full rebuild (fast path).

Threading:

Partition SVO builds by spatial region/node range across threads.
Each thread uses its own FrameArena sub-slice.
Concatenate ranges after.
Cone tracing per-tile can be trivially parallel.

Why this fits Ikyo's philosophy

Monolithic and explicit: World owns concrete storages for exactly the components the engine uses. No plugin registry or reflection.
Uses existing allocators end-to-end:

EngineBuffer routes to Binned/Large automatically; FrameArena for per-frame.
No Foundation containers in hot paths.

DOD-first:

SoA arrays, cache-aligned, pointer-based iteration.
Queries return dense index lists with zero hashing in the render frame.

Swift pitfalls avoided:

No protocol existentials in hot loops, no ARC, no dynamic dispatch, minimal closures.

SVOGI + SVO-DDA optimized:

Fixed component combinations (Voxelizable, Lights, Transparent) fit sparse-set + cached views perfectly.
SVO build/mip/cone tracing stages integrate cleanly with ECS via views.
Incremental revoxelization leverages change tracking (VoxelizeDirty).

Next steps and incremental delivery

Implement EntityManager and PackedSparseSet as above (single-file first).
Add components: Transform, MaterialPBR, TagVoxelizable, Lights, Transparent, BoundsAABB, MeshRef, VoxelizeDirty.
Implement buildVoxelizeView, buildDynamicVoxelizeView, buildLightViews with FrameArena.
Integrate world.beginFrame/world.endFrame with frame arena reset and BinnedAllocator.flushTLS().
Implement SVOScene/SVOGIState structures and LargeAllocator-based buffer creation.
Implement BuildSVOSystem/BuildSVOMipsSystem/LightInjectionSystem.
Implement GBufferSVOPass/SVOGIConeTraceSystem/ReflectionPass/TransparentPass/ShadowPass.
Profile: if Transform access dominates, split Transform into Position/Rotation/Scale SoA storages only if needed.

This design gives you high-throughput, cache-friendly iteration for SVOGI + SVO-DDA ray marching, leverages your allocators directly, stays monolithic, and uses Swift generics to avoid runtime costs on hot paths. The architecture is optimized for the new rendering pipeline (SVOGI cone tracing + SVO-DDA ray marching) while maintaining the strengths of the original design.
