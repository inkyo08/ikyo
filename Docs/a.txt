Based on this Ikyo game engine codebase, design a high-performance ECS (Entity Component System) architecture that fits the existing structure and philosophy.

Requirements:

Follow the monolithic architecture philosophy (no plugins, integrated)
Use the existing custom memory allocators (BinnedAllocator, LargeAllocator, Arena)
Optimize for ray marching rendering workload
Maximum performance - leverage Swift's generics and avoid protocol existentials in hot paths
Design for DOD (Data-Oriented Design) principles
Consider that this is a full ray marching renderer (not traditional rasterization)

Please provide:

Complete ECS architecture design (sparse-set vs archetype recommendation)
Concrete code structure and file organization
Integration points with existing memory system
How to structure components, systems, and queries for ray marching workloads
Performance-critical considerations specific to this codebase



----

Below is a concrete ECS design for Ikyo that stays monolithic, uses your allocators directly, and is tuned for a ray marching renderer and Swift performance characteristics. It prioritizes SoA layout, generics-only APIs, and avoiding ARC and protocol existentials in hot paths.

Architecture: hybrid sparse-set with cached views (SoA), not archetypes

Rationale:

Ray marching traverses a small, known set of components (Transform + SDF primitive family + Material [+ tags]). The set of commonly queried component combinations is fixed and small.
Sparse-set storages yield O(1) add/remove, stable contiguous iteration order, and no wholesale row moves on composition changes (unlike archetypes).
We retain cache-friendly dense arrays per component (SoA). Queries intersect dense arrays once and then stream the result every frame.
We add precomputed “views” (cached intersections) for hot combinations (e.g., Renderable + Transform + Sphere) to eliminate repeated set intersections per frame. These “views” are rebuilt incrementally on add/remove or lazily per frame using FrameArena.
Archetypes are overkill here and introduce fragmentation, higher mutation costs, and complexity that does not benefit a monolithic, fixed-system renderer.

Core design:

Entity = 32-bit packed ID (index: 24 bits, generation: 8 bits) or 20/12 if you prefer. Generations prevent ABA reuse. Free-list for reuse.
ComponentStorage: packed sparse-set with:

denseEntities: EngineBuffer
dense: EngineBuffer (aligned to 64 bytes)
sparse: paged or flat EngineBuffer mapping entityIndex -> denseIndex (or -1)
size/capacity with manual grow using LargeAllocator (via EngineBuffer).
Add/Remove/Has/Get Unsafe pointer APIs for hot paths, no existential/protocol machinery.

Query views:

Small fixed structs that hold precomputed dense index lists for specific combinations, rebuilt when marked dirty.
Store view membership bitset/tagged bloom for quick incremental invalidation if desired (optional).

Systems are plain functions parametrized over storages. No protocol System. Keep hot loops monomorphic.

Concrete code structure and file organization

ecs/Entity.swift

Entity (UInt32 id), EntityManager with generations, freelist, capacity management.

ecs/storage/PackedSparseSet.swift

struct PackedSparseSet { … } using EngineBuffer, EngineBuffer, EngineBuffer
inline add/remove/has/get/forEach

ecs/storage/PackedSparseSet.swift

struct PackedSparseSet { … } using EngineBuffer, EngineBuffer, EngineBuffer
inline add/remove/has/get/forEach

ecs/World.swift

final class World { entities, and concrete storages:

transforms: PackedSparseSet
materials: PackedSparseSet
renderable: PackedSparseSet (tag = Empty struct)
sdfSphere: PackedSparseSet
sdfBox: PackedSparseSet
sdfCapsule: PackedSparseSet
optional: sdfUnion/sdfDifference nodes if you do CSG-level authoring (but see note below).
cached views (structs), dirty flags
per-frame frameArena: FrameArena
}

ecs/Query.swift

functions to build views for (Renderable + Transform + SDFSphere), etc.; return arrays of dense indices using FrameArena.

ecs/Systems/*

Spawn/Destroy/Attach components
Transform propagation (if you do hierarchies, otherwise keep transforms local)
BuildRayMarchSceneSystem (compile ECS to a packed scene for the ray marcher)

render/raymarch/RayMarchScene.swift

struct RayMarchScene { per-type arrays and optional spatial bins; allocated per frame in FrameArena }

render/raymarch/RayMarchSystems.swift

BuildRayMarchScene(world: World) -> RayMarchScene
RayMarchRender(world: World, scene: RayMarchScene, …)

memory integration is already provided in Allocator.swift, BinnedAllocator.swift, LargeAllocator.swift, Arena.swift

Integration with the existing memory system

Persistent storages:

Use EngineBuffer internally for dense arrays. EngineBuffer already routes small to BinnedAllocator and >4KB to LargeAllocator. Specify alignment = max(64, MemoryLayout.alignment) for cache line alignment in SoA buffers.
PackedSparseSet’s metadata (counts, capacities, simple arrays < 4KB) naturally go through BinnedAllocator.

Frame-temporary data:

Use FrameArena for:

Query intersections and temporary lists
Per-frame RayMarchScene build products (SoA arrays, grids)

world.endFrame():

BinnedAllocator.shared.flushTLS()
frameArena.endFrame()

Large CPU working sets (scene arrays) and scene compile:

Allocate big per-frame arrays out of FrameArena so they reset cheaply; avoid ARC containers in hot paths.

Components, systems, and queries tuned for ray marching
Components (POD-only; no ARC members):

Transform: position (Float3), rotation (Quaternion32 or 3x3), scale (Float3). Size ~48–64B.
Material: baseColor (Float3 or packed), emission (Float3), roughness/metalness (packed UInt32 or floats).
TagRenderable: Empty struct (tag).
BoundsSphere: Float4 (center.xyz, radius) for coarse culling and conservative SDF bound.
Per-primitive SDF components (one per entity):

SDFSphere { radius: Float }
SDFBox { halfExtents: Float3; round: Float }
SDFCapsule { a: Float3, b: Float3, radius: Float } if needed
Optional: SDFOpModifier components like SDFSmoothUnion { k: Float } are better compiled away into the RayMarchScene (see below).
Guideline: Avoid polymorphism. Each primitive type has its own component storage (SoA). Systems do per-type loops.

Systems:

TransformSystem (optional hierarchy): precompute world transforms if you have parents. Store only final transform in Transform to keep hot loops simple.
BoundsSystem: compute/update BoundsSphere from Transform + primitive parameters (SoA, strided).
BuildRayMarchSceneSystem:

Inputs: world storages: TagRenderable + Transform + one-of SDF types (+ Material, + BoundsSphere)
Output: RayMarchScene with per-type SoA arrays. Uses FrameArena for allocations.
Optional: build a simple uniform spatial grid or cell list to cull primitives per tile/region. This is useful even for SDFs: while SDFs are global functions, distance bounds culling drastically reduces the candidate set per ray.

RayMarchRenderSystem:

Fetch RayMarchScene; for each ray dispatch, consult the spatial bin to get a compact candidate list; march and evaluate SDF distances per primitive type with type-specialized loops (no dynamic dispatch or existential protocols).

Queries:

Use cached “views” for common intersections. Example: Renderable + Transform + SDFSphere (+ Material?).

Each storage has a denseEntities array. Build an intersection by picking the smallest dense set (e.g., sdfSphere) and checking membership in the others via sparse indices.
Cache these entity lists (EngineBuffer) or just dense indices (EngineBuffer) in World for reuse in the same frame. Mark dirty on add/remove in any of the involved storages.


Performance-critical considerations specific to Ikyo + Swift + ray marching

Avoid ARC and existentials:

All components are POD structs. No class references or closures captured in hot loops.
No protocol Component or System in hot paths. Use generic functions on concrete types.

Prefer monomorphic hot loops:

Separate loops per primitive type for marching; no switch-per-element inside the loop.
@inlinable and @inline(__always) on tight loops and accessors for specialization.

SoA and alignment:

Use EngineBuffer with alignment >= 64 for dense arrays.
For transforms/materials, the component itself is an AoS record; this is okay if you access them together. If you access individual fields independently, split them into separate SoA storages (e.g., Position3, RotationQ, Scale3). Start with AoS Transform and split only if profiling demands it.

Bounds-first:

Maintain BoundsSphere for each instance; test bound during marching to generate a per-ray candidate set early.
Build a very lightweight spatial bin per frame (FrameArena) keyed by screen tiles or world space grid; store lists of instance indices.

Memory/tooling integration:

End-of-frame: FrameArena.reset + BinnedAllocator.flushTLS
EngineBuffer clean dealloc goes through allocator with exact sizes.
For very large read-mostly arrays (e.g., scene compile results), consider vmAdviseHuge(region, enable: true) when supported to reduce TLB misses on Linux; call once after FrameArena commit if you keep a persistent arena for scene data (optional).

Swift micro-optimizations:

Access withUnsafeMutableBufferPointer to remove bounds checks in loops.
Prefer while loops with pointer bumping over for-in when truly hot.
Avoid capturing closures in tight loops; provide manual loop functions.
Mark storages and world final and internal functions @inlinable for cross-file inlining (since monolithic).

Threading:

Partition builds by primitive type across threads, each thread writing to its own FrameArena sub-alloc (or pre-slice the output arrays). Concatenate ranges after.
Be careful not to share EngineBuffer across threads mutably without partitioning. Ray marching per-tile can be trivially parallel.

Key structs and APIs (concise sketches)

ecs/Entity.swift
struct Entity { var raw: UInt32 } // 24-bit index, 8-bit gen
@inline(_always) func entityIndex( e: Entity) -> Int { Int(e.raw & 0x00FF_FFFF) }
@inline(_always) func entityGen( e: Entity) -> UInt8 { UInt8((e.raw >> 24) & 0xFF) }

final class EntityManager {
private var generations: EngineBuffer
private var freeList: [UInt32] = []
private(set) var capacity: Int
init(initial: Int = 8192) { ... allocate generations via EngineBuffer ... }
func create() -> Entity { ... }
func destroy(_ e: Entity) { ... bump gen, push index to freeList ... }
@inline(_always) func alive( e: Entity) -> Bool { generations[eIndex] == eGen }
}

ecs/storage/PackedSparseSet.swift
struct PackedSparseSet {
// SoA: dense values and dense->entity mapping
private var values: EngineBuffer
private var entities: EngineBuffer
// sparse maps entityIndex -> denseIndex+1 (0 means empty), keeps array small and branchless
private var sparse: EngineBuffer
private(set) var count: Int
private var capacity: Int

init(initialCapacity: Int = 1024, align: Int = 64) { ... values = EngineBuffer(count: initialCapacity, alignment: align) ... }
mutating func ensureCapacity(_ n: Int) { ... grow all three buffers (values/entities/sparse) using LargeAllocator via EngineBuffer ... }
@inline(_always) func has( e: Entity) -> Bool { let i = entityIndex(e); return i < sparse.count && sparse[i] != 0 }
@inline(_always) mutating func add( e: Entity, _ v: T) { ... push back into dense; update sparse[entityIndex]=denseIndex+1 }
@inline(_always) mutating func remove( e: Entity) { ... swap-remove from dense; update sparse; maintain entities[] }
@inline(_always) func getPtr( e: Entity) -> UnsafeMutablePointer? { ... return &values.bufferPointer[denseIndex] }
@inline(_always) func forEach( body: (UnsafeMutablePointer, Entity) -> Void) { // monomorphic loop
let vp = values.bufferPointer
let ep = entities.bufferPointer
var i = 0
while i < count {
body(vp.advanced(by: i), ep.advanced(by: i).pointee)

i &+= 1
}
}
}

ecs/World.swift
struct Transform { var pos: SIMD3; var rot: simd_quatf; var scl: SIMD3 }
struct Material { var base: SIMD3; var emissive: SIMD3; var packed: UInt32 }
struct TagRenderable {}
struct BoundsSphere { var center: SIMD3; var radius: Float }
struct SDFSphere { var radius: Float }
struct SDFBox { var halfExtents: SIMD3; var round: Float }
// add more as needed

struct RMViewSphere { var indices: EngineBuffer } // dense indices into sdfSphere storage; built per frame in arena
// Similarly RMViewBox, etc.

final class World {
let entities = EntityManager(initial: 65536)
var transforms = PackedSparseSet()
var materials = PackedSparseSet()
var renderable = PackedSparseSet()
var bounds = PackedSparseSet()
var sdfSphere = PackedSparseSet()
var sdfBox = PackedSparseSet()
// Cached views (recreated per frame into FrameArena)
var viewSphereCountDirty = true
// Per-frame arena
private let frameArena = FrameArena(reserveSize: 64 * 1024 * 1024)!

func beginFrame() { /* mark views dirty if you track structural changes lazily */ }
func endFrame() {
BinnedAllocator.shared.flushTLS()
frameArena.endFrame()
}
func arena() -> FrameArena { frameArena }
}

ecs/Query.swift
@inline(__always)
func buildRenderableSphereView(world: World, arena: FrameArena) -> RMViewSphere {
let srcCount = world.sdfSphere.count
let out = EngineBuffer(count: srcCount, alignment: 64, allocator: IkyoAlloc.global)!
let outPtr = out.bufferPointer
let entPtr = world.sdfSphere.entities.bufferPointer
var outCount = 0
var i = 0
while i < srcCount {
let e = entPtr.advanced(by: i).pointee
if world.renderable.has(e) && world.transforms.has(e) {
outPtr.advanced(by: outCount).pointee = Int32(i)
outCount &+= 1
}
i &+= 1
}
// shrink-if-needed (optional) or just store count separately
return RMViewSphere(indices: out /* keep count separately if desired */)
}

render/raymarch/RayMarchScene.swift
struct RayMarchScene {
// Per-type SoA of instance data pretransformed (if needed):
var sphereCenter: UnsafeMutablePointer<SIMD3>
var sphereRadius: UnsafeMutablePointer
var sphereMaterial: UnsafeMutablePointer
var sphereCount: Int
// same for box, etc.
// Optional spatial bins built per frame:
var gridCellOffsets: UnsafeMutablePointer?
var gridIndices: UnsafeMutablePointer?
var gridCellCount: Int
}

render/raymarch/RayMarchSystems.swift
func buildRayMarchScene(world: World) -> RayMarchScene {
let arena = world.arena()
// Build sphere view
let view = buildRenderableSphereView(world: world, arena: arena)

// Allocate SoA for spheres
let n = world.sdfSphere.count // or the view count
let centers = arena.alloc(bytes: n * MemoryLayout<SIMD3>.stride, align: 64)!.bindMemory(to: SIMD3.self, capacity: n)
let radii = arena.alloc(bytes: n * MemoryLayout.stride, align: 64)!.bindMemory(to: Float.self, capacity: n)
let mats = arena.alloc(bytes: n * MemoryLayout.stride, align: 64)!.bindMemory(to: UInt32.self, capacity: n)

// Fill from storages using dense indices in the view (no hash lookups)
let sphereVals = world.sdfSphere.values.bufferPointer
let entPtr = world.sdfSphere.entities.bufferPointer
let trVals = world.transforms.values.bufferPointer
let matVals = world.materials.values.bufferPointer
var i = 0
while i < n {
let di = Int(view.indices.bufferPointer.advanced(by: i).pointee)
let e = entPtr.advanced(by: di).pointee
let t = trVals.advanced(by: world.transforms.sparse.bufferPointer[entityIndex(e)] - 1).pointee // or store transforms at same dense index if you co-pack; simplest is getPtr(e)!
let s = sphereVals.advanced(by: di).pointee
centers[i] = t.pos // or computed center from transform
radii[i] = s.radius * maxComponent(t.scl)
// material is optional; if missing, write default
var mp: UInt32 = 0
if let mpPtr = world.materials.getPtr(e) { mp = mpPtr.pointee.packed }
mats[i] = mp
i &+= 1
}

// Optionally build a simple uniform grid into arena for coarse culling
// Fill RayMarchScene and return
return RayMarchScene(
sphereCenter: centers,
sphereRadius: radii,
sphereMaterial: mats,
sphereCount: n,
gridCellOffsets: nil,
gridIndices: nil,
gridCellCount: 0
)

func rayMarchRender(world: World, scene: RayMarchScene) {
// Render loop specialized per primitive type, traversing scene.sphere* arrays
// Prefer separate functions per primitive to keep monomorphic
}

Performance notes on the ray marching path

Group by primitive type and run type-specialized marching kernels. This avoids runtime switching and improves branch prediction.
Keep per-ray candidate lists tiny:

Use BoundsSphere plus a simple grid built per frame to preselect candidates per pixel tile or ray packet. Even a coarse 32^3 grid gives big wins.

Evaluate transforms minimally:

Either bake the center/radius/box extents into the scene arrays at compile time (preferred), or keep transforms separate but contiguous and prefetch them.

Keep data hot and packed:

Pack material data tightly (e.g., packed RGBA16F or 10-bit formats into UInt32) to reduce bandwidth in the marching loop.

Use FrameArena for all transient arrays and candidate lists; no ARC, no retain/release.
Put @inlinable and @inline(__always) on:

PackedSparseSet.getPtr/add/remove/has
Query builders
Distance evaluators for each primitive type

Notes on CSG and SDF graph authoring

A dynamic SDF graph with arbitrary nodes would force polymorphism. For performance, compile authoring-time CSG into flat instance data and store only instance-level modifiers (e.g., smooth k) as SoA fields when possible.
If you must support complex nodes, compile them per frame into a linear program (bytecode) stored in FrameArena and interpret it in a tight loop. Still avoid protocol existentials; use an enum opcode with specialized interpreters.

Why this fits Ikyo’s philosophy

Monolithic and explicit: World owns concrete storages for exactly the components the engine uses. No plugin registry or reflection.
Uses existing allocators end-to-end:

EngineBuffer routes to Binned/Large automatically; FrameArena for per-frame.
No Foundation containers in hot paths.

DOD-first:

SoA arrays, cache-aligned, pointer-based iteration.
Queries return dense index lists with zero hashing in the render frame.

Swift pitfalls avoided:

No protocol existentials in hot loops, no ARC, no dynamic dispatch, minimal closures.

Next steps and incremental delivery

Implement EntityManager and PackedSparseSet as above (single-file first).
Add Transform, SDFSphere/Box, Material, TagRenderable, BoundsSphere components.
Implement BuildRayMarchSceneSystem generating per-type SoA arrays with FrameArena.
Integrate world.beginFrame/world.endFrame with frame arena reset and BinnedAllocator.flushTLS().
Profile: if Transform access dominates, split Transform into Position/Rotation/Scale SoA storages only if needed.
Add simple spatial grid build in BuildRayMarchSceneSystem using FrameArena; cull candidates per ray/tile.

This design gives you high-throughput, cache-friendly iteration for ray marching, leverages your allocators directly, stays monolithic, and uses Swift generics to avoid runtime costs on hot paths.